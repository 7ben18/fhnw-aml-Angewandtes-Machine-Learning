---
title: "aml-mc-hs23-ben"
author: "Si Ben Tran"
date: "31.12.2023"
subtitle: Product Affinity Modelling
---

# Aufgaben
Aufgabe: Entwickle und evaluiere Affinitätsmodelle für Kreditkarten auf 
Basis von transaktionellen Kundeninformationen mittels binärer 
Klassifikation in Hinsicht auf personalisierte Werbekampagnen.

# Inhalt
• Aufbereitung eines Modellierungsdatensatz,  
• Modellentwicklung und systematischer Performance-Vergleich,  
• Vergleich der Haupteinflussfaktoren und Top-N Listen der Modelle,  
• Modell-Selektion und systematische Hyperparameter-Optimierung,  
• Modellvereinfachung und -beschreibung für Non-Data Scientist.  

# Libraries Laden
```{r echo=FALSE}
library(tidyverse)
library(tidymodels)
library(DataExplorer)
library(lubridate)
library(eeptools)
library(zoo)
```


# 1. Daten
Laden, transformieren und überprüfen der Datenqualität mittels 
explorativer Datenanalyse; entfernen von Junior-Kreditkarten Kunden.

## 1.1 Laden
Insgesamt werden 8 verschiedene csv Files zur Verfuegung gestellt.
Die Beschreibungen der Daten sind hier zu finden: https://sorry.vse.cz/~berka/challenge/PAST/index.html

```{r read dataframe}
# alle file namen
file_names <- c(
  "account.csv", "card.csv", "client.csv", "disp.csv",
  "district.csv", "loan.csv", "order.csv", "trans.csv"
)

# leere liste fuer dataframes
data_frames <- list()

# For loop durch file_name
for (file_name in file_names) {
  # path definieren
  file_path <- file.path("xselling_banking_data", file_name)

  # daten einlesen und in liste speichern
  data_frames[[file_name]] <- read.csv(file_path, header = TRUE, sep = ";")
}

# dataframes zuweisen
account <- data_frames[["account.csv"]]
card <- data_frames[["card.csv"]]
client <- data_frames[["client.csv"]]
disp <- data_frames[["disp.csv"]]
district <- data_frames[["district.csv"]]
loan <- data_frames[["loan.csv"]]
order <- data_frames[["order.csv"]]
trans <- data_frames[["trans.csv"]]
```


## 1.2 transformieren
### 1.2.1 account
Die Tabelle account besitzt 4 Spalten, die account_id selbst, district_id welches auf die tabelle district verweist. 
Frequency welches die Haeufigkeit der Austellung von Kontoauszuegen definiert sowie ein datum. 

Die Werte von frequency und datum muessen umgeaendert werden, weiter aendern wir ebenfalls den spaltenname von frequency zu issuance_statement_frequency.
```{r wrangle account}
# Frequency
account <- account %>%
  mutate(frequency = case_when(
    frequency == "POPLATEK MESICNE" ~ "MONTHLY ISSUANCE",
    frequency == "POPLATEK TYDNE" ~ "WEEKLY ISSUANCE",
    frequency == "POPLATEK PO OBRATU" ~ " ISSUANCE AFTER TRANSACTION",
    TRUE ~ frequency # Keep other values unchanged
  )) %>%
  rename(issuance_statement_frequency = frequency)

# Datum
account$date <- ymd(account$date)

# Zuweisen zur df liste
data_frames[["account.csv"]] <- account

account %>% sample_n(size = 5)
```

### 1.2.2 card
Die Tabelle card beinhaltet die card_id, dis_id (verweist auf disp df) 
type der Karte und issued. 
Bei card aendern wir das Format in YYMMDD um und ignorierien die Zeit. 
(Auch gemaess der Dokumentation, ist keine Zeit vorgesehen.)
```{r wrangle card}
# Datum formatieren
card$issued <- as_date(ymd_hms(card$issued))

# Zuweisen zur df Liste
data_frames[["card.csv"]] <- card

# Df ausgeben
card %>% sample_n(size = 5)
```

### 1.2.3 client
client Tabelle hat client_id, birht_number mit einem speziellen Format, YYMMDD
fuer Maenner und YYMM + 50 DD fuer Frauen. Also sprich, wurden bei Frauen der Geburtsmonat um 50 addiert. Weiter gibt es noch die district_id, welches auf die district Tabelle verweist. 
```{r wrangle client}
# Funktion zur Geschlechterbestimmung
get_gender <- function(birth_number) {
  year <- as.integer(substr(birth_number, 1, 2))
  month <- as.integer(substr(birth_number, 3, 4))
  day <- as.integer(substr(birth_number, 5, 6))

  # Bei Frauen wird der Geburtsmonat um 50 addiert
  if (month > 12) {
    gender <- "female"
  } else {
    gender <- "male"
  }

  return(gender)
}

# Geschlecht bestimmen und als neue Spalte hinzufügen
client$gender <- sapply(client$birth_number, get_gender)


# filter nach Frauen, erstelle jahr (19XX), Monat - 50 und Tag Spalte sowie Geburtstag.
client_female <- client %>%
  filter(gender == "female") %>%
  mutate(birth_number,
    year =
      as.integer(paste("19", as.character(substr(birth_number, 1, 2)), sep = "")),
    month =
      as.integer(substr(birth_number, 3, 4)) - 50,
    day =
      as.integer(substr(birth_number, 5, 6)),
    birth_day =
      make_date(year, month, day)
  ) %>%
  select(client_id, year, month, day, birth_number = birth_day, district_id, gender)

# Analog fuer Maenner
client_male <- client %>%
  filter(gender == "male") %>%
  mutate(birth_number,
    year =
      as.integer(paste("19", as.character(substr(birth_number, 1, 2)), sep = "")),
    month =
      as.integer(substr(birth_number, 3, 4)),
    day =
      as.integer(substr(birth_number, 5, 6)),
    birth_day =
      make_date(year, month, day)
  ) %>%
  select(client_id, year, month, day, birth_number = birth_day, district_id, gender)

# Anzahl Zeilen ueberpruefen, ob diese mit dem Ursprungs DataFrame uebereinstimmen.
if (nrow(rbind(client_female, client_male)) == nrow(client)) {
  client <- rbind(client_female, client_male)
}

# Berechnung des Alters auf basisjahr 31.12.1999
client$age <- age_calc(dob = client$birth_number, enddate = as.Date("1999-12-31"), units = "years", precise = FALSE)

# zuweisen zur df liste
data_frames[["client.csv"]] <- client

# ausgeben
client %>% sample_n(size = 5)
```

### 1.2.4 disp
disp hat disp_id, client_id, welches auf client dataframe verweist und account_id, welches auf account Tabelle verweist sowie den typ, wobei nur OWNER einen Dauerauftrag erstellen koennen und Kredite aufnehmen koennen.
```{r wrangle disp}
disp %>% sample_n(size = 5)
```

### 1.2.5 district
district hat nummerierte Spalten von A1 - A16. Dabei sind die Kurzel jeweils auf der Website aufgelistet fuer was diese stehen. Wir bennen die Spalten um, damit wir eine Ahnung haben, mit was wir arbeiten sollten. 

A1  district_id/district code	
A2	district name	
A3	region	
A4	no. of inhabitants	
A5	no. of municipalities with inhabitants < 499	
A6	no. of municipalities with inhabitants 500-1999	
A7	no. of municipalities with inhabitants 2000-9999	
A8	no. of municipalities with inhabitants >10000	
A9	no. of cities	
A10	ratio of urban inhabitants	
A11	average salary	
A12	unemploymant rate '95	
A13	unemploymant rate '96	
A14	no. of enterpreneurs per 1000 inhabitants	
A15	no. of commited crimes '95	
A16	no. of commited crimes '96

```{r wrangle district}
district <- district %>% select(
  district_id = A1, district_name = A2,
  region = A3, num_of_habitat = A4,
  num_of_small_town = A5, num_of_medium_town = A6,
  num_of_big_town = A7, num_of_bigger_town = A8,
  num_of_city = A9, ratio_of_urban = A10,
  average_salary = A11, unemploy_rate95 = A12,
  unemploy_rate96 = A13, n_of_enterpren_per1000_inhabit = A14,
  no_of_crimes95 = A15, no_of_crimes96 = A16
)

# zuweisen zur df liste
data_frames[["district.csv"]] <- district

district %>% sample_n(size = 5)
```

### 1.2.6 loan
Loan hat loan_id, account_id (verweis auf account Tabelle), date in YYMMDD Format, amount, duration, payments, status.
Aendern werden wir payments zu monthly_payments und die Werte von
status. 
'A' stands for contract finished, no problems, => contract finished
'B' stands for contract finished, loan not payed, => finished contract, loan not payed
'C' stands for running contract, OK so far, => running contract
'D' stands for running contract, client in debt => client in debt

Weiter checken wir, ob ein Account mehrere Loans haben kann, Gruppieren nach account und zaehlen die Anzahl Zeilen. Diese Fuegen wir dann spaeter zu unserem Loan DataFrame hinzu als weiteres Feature. 

```{r wrangle loan}
loan$date <- ymd(loan$date)

loan <- loan %>%
  mutate(status = case_when(
    status == "A" ~ "contract finished",
    status == "B" ~ "finished contract, loan not paid",
    status == "C" ~ "running contract",
    status == "D" ~ "client in debt",
  ))

num_of_loan_df <- loan %>%
  group_by(account_id) %>%
  summarize(num_of_loan = n()) %>%
  arrange(desc(num_of_loan))

num_of_loan_df

loan <- inner_join(
  x = loan,
  y = num_of_loan_df,
  by = "account_id"
)


# Zuweisen zur df liste
data_frames[["loan.csv"]] <- loan

loan %>% sample_n(size = 5)
```

### 1.2.7 order
die order Tabelle besteht aus order_id, account_id, bank_to (einzigartige Komibination aus 2 Buchstaben), account_to (zu welchem Account), amount, k_symbol (klassifizierung der Zahlung)
k_symbol wird auf englisch uebersetzt

Da es accounts gibt die keine Orders haben, versuchen wir den Order Datensatz zu erweitern, indem wir von account, account_id einen left join machen. Somit erhalten wir alle account auch diejenigen die keine order besitzen. Diese haben NA Werte, welche wir dann mit 0 beim Amount und "UNKOWN" bei k_symbol ersetzen.

Ein account kann mehrere Orders haben, um spaeter einfacher joinen zu koenen versuchen wir durch aggregieren nach account_id die Summe, Mittelwert, Median Ausgaben zu erhalten. Bei den Kategorischen Spalte k_symbol versuchen wir diese One-Hot zu encoden. 
```{r wrangle order}
order <- order %>%
  mutate(k_symbol = case_when(
    k_symbol == "POJISTNE" ~ "INSURRANCE PAYMENT",
    k_symbol == "SIPO" ~ "HOUSHOLD",
    k_symbol == "UVER" ~ "LOAN PAYMENT"
  ))

order$k_symbol[is.na(order$k_symbol)] <- "UNKOWN"


# create a dataframe that contains all account_id from account
account_id_df <- account %>%
  select(account_id)

# make a left join with order, every account that doesnt have an order will have NA values
order <- left_join(
  x = account_id_df,
  y = order,
  by = "account_id"
) %>% # create a column has_order if the row is complete
  mutate(has_order = !rowSums(is.na(.))) # if k_symbol NA then replace with "UNKOWN"

order$k_symbol[is.na(order$k_symbol)] <- "UNKOWN"

order$amount[is.na(order$amount)] <- 0

# Aggregating amount
aggregated_amount <- order %>%
  group_by(account_id) %>%
  summarise(
    sum_amount = sum(amount, na.rm = TRUE),
    mean_amount = mean(amount, na.rm = TRUE),
    median_amount = median(amount, na.rm = TRUE),
    min_amount = min(amount, na.rm = TRUE),
    max_amount = max(amount, na.rm = TRUE),
    num_of_orders = sum(amount != 0) # Count non-zero orders
  )


# create a column has_order if the sum_amount is 0 == False
aggregated_amount$has_order <- aggregated_amount$sum_amount != 0

aggregated_amount

# Creating dummies
dummies_k_symbol <- order %>%
  select(account_id, k_symbol) %>%
  pivot_wider(
    names_from = k_symbol,
    values_from = k_symbol,
    values_fill = 0,
    values_fn = length
  )

dummies_k_symbol

# Merging dataframes
order <- left_join(aggregated_amount, dummies_k_symbol, by = "account_id")

# zuweisen zur df liste
data_frames[["order.csv"]] <- order

order %>% sample_n(size = 5)
```


### 1.2.8 trans
Die trans Tabelle hat trans_id, account_id, date, type, operation, amount und banalce, k_symbol (analog zu order) bank und account


type, operation und k_symbol Werte werden auf Englisch uebersetzt
```{r wrangle trans}
trans <- trans %>%
  mutate(
    date = ymd(date),
    type = case_when(
      type == "PRIJEM" ~ "CREDIT",
      type == "VYDAJ" ~ "WITHDRAWAL"
    ),
    operation = case_when(
      operation == "VYBER KARTOU" ~ "CREDIT CARD WITHDRAWAL",
      operation == "VKLAD" ~ "CREDIT IN CASH",
      operation == "PREVOD Z UCTU" ~ "COLLECTION FROM ANOTHER BANK",
      operation == "VYBER" ~ "WITHDRAWAL IN CASH",
      operation == "PREVOD NA UCET" ~ "REMITTANCE TO ANOTHER BANK"
    ),
    k_symbol = case_when(
      k_symbol == "POJISTNE" ~ "INSURRANCE PAYMENT",
      k_symbol == "SLUZBY" ~ "STATEMENT PAYMENT",
      k_symbol == "UROK" ~ "INTEREST CREDITED",
      k_symbol == "SANKC. UROK" ~ "INTERES IF NEGATIVE BALANCE",
      k_symbol == "SIPO" ~ "HOUSHOLD",
      k_symbol == "DUCHOD" ~ "OLD-AGE PENSION",
      k_symbol == "UVER" ~ "LOAN PAYMENT",
    )
  )

# Zuweisen zur df liste
data_frames[["trans.csv"]] <- trans

trans %>% sample_n(size = 5)
```

## 1.3 Datenqualität mittels eda

### 1.3.1 Fehlende Werte
Wir erkennen, dass die Transaktions Daten in der Tabelle order und trans fehlende Werte aufweisen. 

```{r fehlende Werte}
# check for missing values in each dataframe
for (i in 1:length(data_frames)) {
  df_name <- names(data_frames)[i] # Get the dataframe name
  cat("Missing values in", df_name, ":\n")
  print(sum(is.na(data_frames[[i]])))
}
```

### 1.3.1 District - Fehlende Werte

Bei genauer Betrachtung des Dataframes "district" ist aufgefallen, dass bei dessen Einlesen die Spalten "unemploy_rate95" und "no_of_crime95" als Zeichenketten (Character) eingelesen wurden. Bei beiden Spalten wurde der ein "?" verwendet statt NA. 
Hier in diesem Code Abschnitt imputieren den fehlenden Wert mit dem Mittelwert der jeweiligen Spalte.

```{r wramgle missing values, warning=FALSE}
# Datentyp convertieren
district$unemploy_rate95 <- as.numeric(district$unemploy_rate95)
district$no_of_crimes95 <- as.numeric(district$no_of_crimes95)

# fehlende Werte plotten
plot_missing(district)

# Imputation mittels mean
district$unemploy_rate95[is.na(district$unemploy_rate95)] <- median(district$unemploy_rate95, na.rm = TRUE)

district$no_of_crimes95[is.na(district$no_of_crimes95)] <- median(district$no_of_crimes95, na.rm = TRUE)

# fehlende Werte nach imputation plotten
plot_missing(district)
```


### 1.3.2 Data Explorer

Wir nutzen Data Explorer für eine erste Grobe Übersicht zu unseren Daten zu erhalten. 

```{r perform eda with DataExplorer}
# Function to perform EDA on a dataframe
perform_eda <- function(df, df_name) {
  # Create a data exploration report for the dataframe
  title <- paste("Exploratory Data Analysis for", df_name)
  create_report(df, report_title = title)

  # You can add more EDA steps here, such as additional plots and analysis
}

# Specify your directory path
path <- "eda-dataexplorer-reports"

# Check if directory exists
if (dir.exists(path)) {
  # List all files in directory
  list_of_files <- list.files(path)

  # Check if directory is empty
  if (length(list_of_files) == 0) {
    # Iterate through the list of dataframes and perform EDA on each
    for (i in 1:length(data_frames)) {
      df_name <- names(data_frames)[i] # Get the dataframe name
      perform_eda(data_frames[[i]], df_name)
    }
  } else {
    cat("Directory is not empty. Not running the EDA code.")
  }
} else {
  cat("Specified path does not exist. Please check the path and try again.")
}
```

Mittels der Funktion perform_eda() generiert für jedes Dataframe eine Explorative Datenanalyse in html Format. Diese sind unter dem Verzeichnis: eda-dataexplorer-reports zu finden. 
Wir betrachten nun alle Dateframes vom Dataexplorer und halten unsere Kentnisse in diesem Abschnitt fest. 

account: 
Account besitzt keine fehlende Werte. Weiter fällt stark auf, dass bei issuance_statement_frequency der meiste vorkommende Wert MONTHLY ISSUANCE ist. 

card:
card besitzt keine fehlende Werte. Beim Barplot vom Typ sehen wir, dass classic die am häufigsten vertretene Klasse ist. Gefolgt wird diese von Junior und auf dem dritten Platz, mit am wenigsten vorkommenden sind gold.

client:
client weist keine fehlende Werte im Datensatz auf. Die Altersverteilung ist leicht linksschief. Wir erkennen im korrelationsplot, dass Jahr und Alter korrelieren, was jedoch nicht verwunderlich ist.

disp:
disp weist keine fehlende Werte im Datensatz auf. Die am meisten vorkommende Variable von type ist OWNER. DISPONENT kommt 1/4 mal weniger vor als OWNER.

district:
district weist ebenfalls keine fehlende Werte auf. average_salary ist rechtsschief verteilt. 

loan:

order:

trans:

## 1.4 Junioren entfernen

### 1.4.1 entfernen von Junior Kreditkarten Kunden
```{r remove junior card}
# checken, welche Variabeln vorhanden sind.
print(paste("Kartentypen:", unique(card$type)))

# !junior dataframe
card_clean <- subset(card, type != "junior")

# junior dataframe
card_junior <- subset(card, type == "junior")

# Berechne Differenz von rows zwischen card_junior und card
print(paste("Anzahl entfernte junior Karten:", nrow(card_junior)))

# entfernen von allen disp_id in disp Dataframe, die in card_junior vorkommen.  (1:1)
disp_clean <- subset(disp, !(disp_id %in% unique(card_junior$disp_id)))
print(paste("Anzahl entfernte disp_id, die von card_junior kommen:", nrow(disp) - nrow(disp_clean)))
```

### 1.4.2 entfernen von junge Kunden

Wir untersuchen die Junioren genauer indem wir eine Visualisierung erstellen, indem wir die Altersverteilungen der Kunden sehen aufgrund dessen, welche Karten sie besitzen. 
Dazu muessen wir schon einige Tabellen miteinander joinen um dies tun zu koennen. 
Weiter haben wir eine Statistische Auswertung des Alters gemacht, indem wir nach card.type gruppieren und das jeweilige Alter aggregieren. Es stellt sich heraus, das die aelteste Person 25 Jahre Alt ist und eine junior Karte bestizt. Da wir in unserem Modell nicht die Junioren ansprechen wollen, entfernen wir zusaetzlich noch alle Kunden die juenger als 26 sind. Relevant bleiben uns somit nur die accounts_id die ueber 25 Jahre alt sind. 

```{r}
# inner join by client_id
client_disp <- inner_join(
  x = client,
  y = disp,
  by = "client_id",
  suffix = c(".client", ".disp")
) %>%
  select(
    client_id,
    district_id,
    disp_id,
    account_id,
    everything()
  ) %>%
  rename(
    "year.client" = "year",
    "month.client" = "month",
    "day.client" = "day",
    "birht_number.client" = "birth_number",
    "gender.client" = "gender",
    "age.client" = "age",
    "type.disp" = "type"
  )

# left join
client_disp_card <- left_join(
  x = client_disp,
  y = card,
  by = "disp_id",
  suffix = c("", ".card")
) %>%
  mutate(has_card = !rowSums(is.na(.))) %>%
  select(-c(disp_id, card_id)) %>%
  rename(
    "type.card" = "type",
    "issued.card" = "issued",
    "has_card.card" = "has_card"
  )

client_disp_card

# create age distribution and color them with type.card
ggplot(client_disp_card, aes(
  x = age.client,
  color = type.card
)) +
  geom_histogram(
    alpha = 0.5,
    fill = "white"
  ) +
  labs(title = "Verteilung von Alter unterteilt nach Kartentyp", x = "Alter", y = "Anzahl") +
  facet_wrap(~type.card)

# get statistical information grouped by type.card for age
client_disp_card %>%
  group_by(type.card) %>%
  summarize(
    mean_age = mean(age.client),
    median_age = median(age.client),
    min_age = min(age.client),
    max_age = max(age.client),
    quantile_75 = quantile(age.client, 0.75)
  )

# create boxplot for age distribution, for each card.type
ggplot(client_disp_card, aes(
  x = type.card,
  y = age.client,
  color = type.card
)) +
  geom_boxplot() +
  labs(title = "Verteilung von Alter unterteilt nach Kartentyp", x = "Kartentyp", y = "Alter")

# remove all junior in type.card but keep NA
client_disp_card_rm_junior <- client_disp_card %>%
  filter(type.card != "junior" | is.na(type.card))

# get all account_ids that are older than 25 years old
client_ids_older_than_25 <- client_disp_card_rm_junior %>%
  filter(age.client > 25) %>%
  select(client_id)

client_ids_older_than_25
```



# 2. Kombinieren 
Kombinieren der Informationen zu Kunden und Bankdienstleistungen.

Durch unsere Skizze die unter als "skizze-tabelle-joinen" abgelegt wurde, wissen wir nun wie die Tabellen miteinander verknuepft sind und konnen so einen Datensatz von Kunden und einen Datensatz von Bankdienstleistungen erstellen.  

## 2.1 client - disp

Wir innen joinen client und disp mit client_id, renamen die Spaltenamen und fügen jeweils ein suffix hinzu, um später noch eine Übersicht zu haben, von welcher Tabelle die Spalte entspringt. Beim inner joinen verlieren wir keine Kunden. Nach dem Joinen wissen wir von jedem Kunden, was für eine Art type der Kunde ist. OWNER oder DISPONENT.  

```{r cmobine client-disp}
# client und disp weisen eine 1:1 relation auf client_id auf.
print(paste("Anzahl Zeilen client df:", nrow(client)))
print(paste("Anzahl Zeilen disp df:", nrow(disp)))

# Inner join client with client_ids_older_than_25 to remove junior and clients age <= 25
client <- inner_join(
  x = client,
  y = client_ids_older_than_25,
  by = "client_id"
)

# inner join by client_id
client_disp <- inner_join(
  x = client,
  y = disp,
  by = "client_id",
  suffix = c(".client", ".disp")
) %>%
  select(
    client_id,
    district_id,
    disp_id,
    account_id,
    everything()
  ) %>%
  rename(
    "year.client" = "year",
    "month.client" = "month",
    "day.client" = "day",
    "birht_number.client" = "birth_number",
    "gender.client" = "gender",
    "age.client" = "age",
    "type.disp" = "type"
  )

print(paste("Anzahl Zeilen client_disp df:", nrow(client_disp)))
client_disp
```

### 2.1.1 gender vs. type
Die meisten unserer Kunden sind vom typ her OWNER. Das Geschlecht ob man OWNER oder DISPONENT ist sehen bei beiden Verteilungen ähnlich gleich aus. 

```{r eda}
ggplot(client_disp, aes(
  x = age.client,
  color = gender.client
)) +
  geom_histogram(
    alpha = 0.2,
    fill = "white",
    position = "dodge"
  ) +
  labs(
    title = "Verteilung von Alter unterteilt nach Geschlecht und Typ",
    x = "Alter",
    y = "Anzahl"
  ) +
  facet_grid(gender.client ~ type.disp)
```

## 2.2 +card

Wir joinen client_disp mit card über disp_id. Nicht jeder Kunde besitzt eine Karte, somit ist ein left join auf client_disp unsere Wahl, um keine Kunden zu verlieren. Weiter wurde eine weitere spalte erstellt, die uns markiert, ob der Kunde eine Karte besitzt oder nicht. Dies könnte später noch relevant werden bei der Evaluierung unsere Modelle.
```{r +card}
# Weiter joinen wir client_disp und card mit disp_id. Auch hier besteht eine 1:1 Beziehung.

# Wir erkennen jedoch, dass es clienten gibt, die keine Karte besitzen. aus diesem Grund

print(paste("Anzahl Zeilen card df:", nrow(card_clean)))

# left join
client_disp_card <- left_join(
  x = client_disp,
  y = card_clean,
  by = "disp_id",
  suffix = c("", ".card")
) %>%
  mutate(has_card = !rowSums(is.na(.))) %>%
  select(-c(client_id, disp_id, card_id)) %>%
  rename(
    "type.card" = "type",
    "issued.card" = "issued",
    "has_card.card" = "has_card"
  )

print(paste("Anzahl Zeilen client_disp_card df:", nrow(client_disp_card)))
client_disp_card
```
### 2.2.1 type vs. has_card
Aus der Visualisierung erkennen wir, dass keine Disponenten existieren die eine Karte besitzen. Aus diesem Grund filtern wir unseren Datensatz nur nach Owner, da wir diesen Personen eine Karte anbieten, bzw Karten wie classic oder gold besitzen bzw. verkaufen koennten. 

```{r eda}
ggplot(client_disp_card, aes(
  x = age.client,
  color = has_card.card
)) +
  geom_histogram(
    alpha = 0.5,
    fill = "white"
  ) +
  labs(title = "Verteilung von Alter unterteilt nach Kartentyp und Art", x = "Alter", y = "Anzahl") +
  facet_grid(type.card ~ type.disp)
```

### 2.2.2 groupby account_id
Kann ein Kunde Disponent und OWNER gleichzeitig sein?

Ja es gibt Account die mehrere Zeilen beinhalten. 
```{r eda}
# groupby account and count number of rows
client_disp_card %>%
  group_by(account_id) %>%
  summarize(num_of_rows = n()) %>%
  arrange(desc(num_of_rows))
```

## 2.3 Filter nach OWNER

Durch das Filtern verlieren wir 869 Kunden. Es bleiben von den 5369 Kunden nun noch 4500. 
```{r filter for owner}
# Filtern nach type.disp == "OWNER"
print(paste("Anzahl entfernte Zeilen von client_disp_card df:", nrow(client_disp_card) - nrow(client_disp_card %>% filter(type.disp == "OWNER"))))

client_disp_card <- client_disp_card %>% filter(type.disp == "OWNER")
client_disp_card
```

### 2.3.1 groupby account_id

Das das Filtern stellen wir nun fest, dass jeder Kunde nur ein Account bei der Bank besitzt. Diese koennen wir nun nutzen, um mit dem DataFrame account zu joinen. 
```{r eda}
# groupby account and count number of rows
client_disp_card %>%
  group_by(account_id) %>%
  summarize(num_of_rows = n()) %>%
  arrange(desc(num_of_rows))
```


## 2.4 + account
Durch die Erkentnisse von 2.3.1 koennen wir nun einen Inner Join durchfuehren von unserem vorhanden dataframe client-disp-card mit account Tabelle. 
Die Anzahl der Kunden bleibt somit gleich auf 4500. 
```{r +account}
# Ein Account kann mehrere disponenten haben.

print(paste("Anzahl Zeilen account df:", nrow(account)))
print(paste("Anzahl Zeilen client_disp_card:", nrow(client_disp_card)))


client_disp_card_account <- inner_join(
  x = account,
  y = client_disp_card,
  by = "account_id"
) %>%
  rename(
    "district_id.account" = "district_id.x",
    "district_id.client" = "district_id.y",
    "issuance_statement_frequency.account" = "issuance_statement_frequency",
    "account_creation_date.account" = "date"
  )


print(paste("Anzahl Zeilen client_disp_card_account df:", nrow(client_disp_card_account)))
client_disp_card_account
```

## 2.5 loan - account

Wir betrachten hier nun account und loan getrennt von unserem gejointen Dataframe. Erst in einem zweiten Schritt joinen wir beide Dataframes dann miteinander. Da ein Account ein Kredit haben kann oder nicht, fuehren wir einen left_join auf account ueber account_id.

```{r loan-account}
# Ein account kann ein Kredit haben oder auch nicht.
account_loan <- left_join(
  x = account,
  y = loan,
  by = "account_id"
) %>%
  mutate(has_loan.loan = !rowSums(is.na(.))) %>%
  rename(
    "date.loan" = "date.y",
    "amount.loan" = "amount",
    "duration.loan" = "duration",
    "payments.loan" = "payments",
    "status.loan" = "status",
    "num_of_loan.loan" = "num_of_loan"
  ) %>%
  select(-c(loan_id, district_id, issuance_statement_frequency, date.x))

account_loan
```

### 2.5.1 NA Werte
Durch das Joinen haben wir viele Spalten erhalten die NA Werte aufweisen. Bzw. nur die Spalten die von Loan kommen. Diese werden durch 0 oder no_loan ersetzt, da diese Accounts keinen Kredit besitzen. Beim Datum belassen wir die NA Werte

```{r reaplce NA values}
# reaplce NA values with 0 or no_loan
account_loan <- account_loan %>%
  mutate(
    amount.loan = ifelse(is.na(amount.loan), 0, amount.loan),
    duration.loan = ifelse(is.na(duration.loan), 0, duration.loan),
    payments.loan = ifelse(is.na(payments.loan), 0, payments.loan),
    status.loan = ifelse(is.na(status.loan), "no_loan", status.loan),
    num_of_loan.loan = ifelse(is.na(num_of_loan.loan), 0, num_of_loan.loan)
  )
```


### 2.5.2 amount vs. payments

Wir betrachten hier nun account und loan getrennt von unserem gejointen Dataframe. Erst in einem zweiten Schritt joinen account_loan und client_disp_card_account mit der Spalte account_id zusammen und fuehren eine kurze explorative Datenanalyse durch. 

Interessant zu sehen ist, dass die meisten Kredite schon abbezahlt wurden die eine Dauer von 12 Monaten aufweisen. 

Viele Account haben keinen Kredit aufgenommen.

```{r eda, warning=FALSE}
# Kredithoehe vs. Payments mit dauer und status
sample_n(account_loan, size = 1000) %>%
  ggplot(aes(
    x = amount.loan,
    y = payments.loan,
    shape = as.factor(duration.loan),
    color = status.loan
  )) +
  geom_point(alpha = 1) +
  labs(
    title = "Zahlung vs. Menge Kredit, unterteilt nach Dauer und",
    x = "Kreditmenge",
    y = "Zahlung"
  )

# Anzahl Kredite unterteilt nach Status
account_loan %>%
  ggplot(aes(
    x = has_loan.loan,
    fill = status.loan
  )) +
  geom_bar(position = "stack") +
  labs(
    title = "Stacked Barplot",
    x = "Kredit",
    y = "Anzahl"
  )
```


## 2.6 + account_loan

Wir joinen nun beide groesseren Dataframes ueber account_id. Beide Dataframes weisen 4500 Zeilen, somit haben wir nach dem joinen immer noch 4500 Kunden, welche 22 Features aufweisen. 
```{r +amount_loan}
# account_loan mit client_disp_card_district_account joinen
client_disp_card_account_loan <- inner_join(
  x = account_loan,
  y = client_disp_card_account,
  by = "account_id"
)

print(paste("Anzahl Zeilen client_disp_card_account df:", nrow(client_disp_card_account_loan)))
client_disp_card_account_loan
```



### 2.6.1 loan vs. card?
Was uns nun intressiert ist der Zusammenhang zwischen eine Karte zu besitzen und einen Kredit aufzuweisen. 

Es gibt Kunden die eine Karte haen und einen Kredit, analog gibt es auch Kunden die keine Karte haben, aber einen Kredit oder nicht. Somit behalten wir in unserem Datensatz die Kundschaft bei.

```{r eda}
client_disp_card_account_loan %>%
  ggplot(aes(
    x = has_loan.loan,
    fill = has_card.card
  )) +
  geom_bar(position = "dodge") +
  labs(
    title = "Barplot",
    x = "Kredit vorhanden?",
    y = "Anzahl"
  ) +
  facet_grid(type.card ~ issuance_statement_frequency.account)
```

### 2.6.2 Anzahl Kunden?
Wir überprüfen unser DataFrame ob eine Zeile einen Kunden entspricht indem wir nach account_id gruppieren und die Rows zaehlen.

In unserem DataFrame ist jede Zeile ein Kunde. Somit konnte jedem Kunden ein Bank Account zugewiesen werden. 
```{r eda}
# groupby account and count number of rows
client_disp_card_account_loan %>%
  group_by(account_id) %>%
  summarize(num_of_rows = n()) %>%
  arrange(desc(num_of_rows))
```

## 2.7 +order

Durch den Inner join mit order haben wir weiterhin die gleiche Anzahl Kunden.


```{r +order}
# inner join by account_id client_disp_card_district_account_loan und order

print(paste("Anzahl Zeilen client_disp_card_account_loan_order df:", nrow(client_disp_card_account_loan)))
print(paste("Anzahl Zeilen order :", nrow(order)))


client_disp_card_account_loan_order <- inner_join(
  x = client_disp_card_account_loan,
  y = order,
  by = "account_id"
) %>%
  rename(
    "sum_amount.order" = "sum_amount",
    "mean_amount.order" = "mean_amount",
    "median_amount.order" = "median_amount",
    "min_amount.order" = "min_amount",
    "max_amount.order" = "max_amount",
    "num_of_orders.order" = "num_of_orders",
    "num_insurrance_payment.order" = "INSURRANCE PAYMENT",
    "num_household.order" = "HOUSHOLD",
    "num_loan_payment.order" = "LOAN PAYMENT",
    "num_unkown.order" = "UNKOWN",
    "has_order.order" = "has_order"
  ) %>%
  arrange(account_id)

print(paste("Anzahl entfernte Zeilen von client_disp_card_account_loan df:", nrow(client_disp_card_account_loan) - nrow(client_disp_card_account_loan_order)))

client_disp_card_account_loan_order
```

## 2.8 +district
Wir erweitern unseren Datensatz mit dem district. Wichtig dabei zu beachten ist, dass wir jeweils einen district fuer die Filiale der Bank haben und einen district fuer den Kunden. In unserem Fall joinen wir unser Dataframe mit dem des Kunden, da uns dieser mehr interessiert, ob geographische Einfluesse den Kauf eines Bank Produktes.

```{r +district}
print(paste("Anzahl Zeilen district df:", nrow(district)))
print(paste("Anzahl Zeilen client_disp_card_account_loan_order:", nrow(client_disp_card_account_loan_order)))

client_disp_card_account_loan_order_district <- left_join(client_disp_card_account_loan_order %>% rename("district_id" = "district_id.client"),
  district,
  by = "district_id"
) %>%
  rename(
    "district_name.district" = "district_name",
    "region.district" = "region",
    "num_of_habitat.district" = "num_of_habitat",
    "num_of_medium_town.district" = "num_of_medium_town",
    "num_of_small_town.district" = "num_of_small_town",
    "num_of_big_town.district" = "num_of_big_town",
    "num_of_bigger_town.district" = "num_of_bigger_town",
    "num_of_city.district" = "num_of_city",
    "ratio_of_urban.district" = "ratio_of_urban",
    "average_salary.district" = "average_salary",
    "unemploy_rate95.district" = "unemploy_rate95",
    "unemploy_rate96.district" = "unemploy_rate96",
    "n_of_enterpren_per1000_inhabit.district" = "n_of_enterpren_per1000_inhabit",
    "no_of_crimes95.district" = "no_of_crimes95",
    "no_of_crimes96.district" = "no_of_crimes96"
  ) %>%
  select(-c(district_id))

print(paste("Anzahl Zeilen client_disp_card_account_loan_order_district df:", nrow(client_disp_card_account_loan_order_district)))

data <- client_disp_card_account_loan_order_district

data
```

## 2.9 +trans?
Ein Account kann mehrere Transaktionen gemacht haben. 
- droppen von unnoetigen Transaktion spalten
- Aggregation fuer Numerische (Mean, Median etc...)
- Aggregation mir Rolling Window von balance und
- OneHotEncoding fuer Kategorische

```{r +trans?}
trans <- trans %>%
  select(-c(trans_id, account, bank)) %>%
  arrange(account_id)
trans
```


```{r}
# filter in trans dataframe for account_id = 1 and 2
trans_1_and_2 <- trans %>% filter(account_id %in% c(1, 2))

# Calculating 30-day rolling mean
trans_1_and_2 <- trans_1_and_2 %>%
  arrange(account_id, date) %>%
  group_by(account_id) %>%
  mutate(rolling_mean = rollmean(balance, k = 30, fill = NA, align = "center"))

trans_1_and_2


# Create a time lineplot, where on the x axis is the date and y axis balance and amount.
ggplot(trans_1_and_2, aes(x = date)) +
  geom_line(aes(
    y = balance,
    color = as.factor(account_id),
    alpha = 0.5,
    linetype = "dashed"
  )) +
  geom_line(
    aes(
      y = rolling_mean,
      color = as.factor(account_id)
    ),
    linetype = "solid"
  ) +
  labs(
    title = "Balance and 30-Day Rolling Mean Over Time",
    x = "Date",
    y = "Balance",
    color = "Account ID"
  )
```


# 3. Identifizierung
Identifizieren bestehender Kreditkartenkäufer inkl. Bestimmung des
Kaufdatums und Rollup-Fensters, definiert durch 1 Monat Lag und 12
Monate History vor Kreditkartenkauf.

## 3.1 Identifizierung bestehender Kreditkartenkaeufer und Kaufdatum

```{r}
# create a dataframe where has_card.card == TRUE
account_ids_has_card <- data %>%
  filter(has_card.card == TRUE) %>%
  select(account_id, issued.card)

account_ids_has_card
```

## 3.2 Rollup-Fenster von Käufer

Das Rollup Fenster definieren wir indem wir vom Kaufdatum 13 Monate subtrahieren (12 Monate History + 1 Monat Lag). Vor dem Kauf einer Kreditkarte kann es gut sein, dass der Kunde sich 1 Monat schon davor entschieden hat eine Karte zu beantragen und diese noch von der Bank verarbeitet werden muss. Aus diesem Grund filtern wir die Transaktionellen Daten zwischen den Bereich start_date (kaufdatum.datum - 13 Monate) und start_lag_date (kaufdatum.card - 1 Monat).

```{r}
# vom Kaufdatum -13 Monate von Kunden die eine Karte besitzen
account_ids_has_card <- account_ids_has_card %>%
  mutate(
    start_date = issued.card %m-% months(13),
    start_lag_date = issued.card %m-% months(1)
  )

account_ids_has_card

# get from transaction all accounts that got a card and filter also by its range
buyers <- inner_join(
  x = account_ids_has_card,
  y = trans,
  by = "account_id"
) %>%
  filter(date >= start_date & date <= start_lag_date) %>%
  select(-c(start_date, start_lag_date))

# check transaction within range
buyers
```

Wir schreiben eine Funktion die uns erlaubt nach beliebige accounts zu filtern die eine Karte besitzen und in unserem Roll-up Fenster sind. Anschliessend fuehren wir eine Visualisierung von balance durch und zeichnen noch zusaetzlich ein rollingwindow von 30 Tagen ein. Wichtig dabei zu beachten ist, dass das lag-Monat nicht mit visualisiert wird! Diese Visualisierung erlaubt es uns, Kunden mit dem Produkt einer Karte besser zu verstehen. 
```{r}
visualize_account_balance <- function(transactions,
                                      accounts_to_filter,
                                      window_size = 30) {
  # Filter transactions by account
  filtered_transactions <- transactions %>%
    filter(account_id %in% accounts_to_filter)

  # Check if filtered data frame is empty
  if (nrow(filtered_transactions) == 0) {
    warning("The provided account_id(s) do not appear in the transactions dataset.")
    return(NULL)
  }

  # Calculate rolling mean
  trans_with_rolling_mean <- filtered_transactions %>%
    arrange(account_id, date) %>%
    group_by(account_id) %>%
    mutate(rolling_mean = rollmean(balance, k = window_size, fill = NA, align = "center"))

  print(trans_with_rolling_mean)

  # visualisere balanace and rolling mean
  plot <- ggplot(trans_with_rolling_mean, aes(x = date)) +
    geom_line(aes(
      y = balance,
      color = as.factor(account_id)
    )) +
    geom_line(
      aes(
        y = rolling_mean,
        color = as.factor(account_id)
      ),
      linetype = "solid"
    ) +
    geom_vline(
      xintercept = as.numeric(unique(filtered_transactions$kaufdatum.card)),
      linetype = "dotdash", color = "black",
    ) +
    labs(
      title = paste(window_size, "-Day Rolling Mean Over Time"),
      x = "Date",
      y = "Balance",
      color = "Account ID"
    )

  return(plot)
}

visualize_account_balance(buyers,
  accounts_to_filter = c(7),
  window_size = 30
)
```

## 3.3 Käufer Eigenschaften

Da wir nun uns in einem richtigen Roll-up Fenster befinden fuer die Kunden extrahieren wir nun das Jahr und den Monat und fuegen diese als weitere Spalte hinzu. Weiter fügen wir dann eine Spalte value = 1, damit das pivotieren einfacher funktioniert. Dadurch haben wir für eine Zeile einen account_id und können diese nun mit unserem grossen Dataframe aus 2. inner_joinen und erhalten die Attribute von Käufer. Einige Attribute sind fuer den Vergleich irrelevant und werden nicht beruecksichtigt.

```{r}
# extract year and month
buyers$year_month <- format(as.Date(buyers$date), "%Y-%m")

buyers

# Pivot wider Dataframe
buyers_pivot <- buyers %>%
  select(account_id, year_month) %>%
  mutate(value = 1) %>%
  pivot_wider(
    names_from = year_month,
    values_from = value, values_fn = sum
  )

buyers_pivot

# check if a row has more than 12 missing values
buyers_pivot %>%
  filter(rowSums(!is.na(.)) < 12) %>% # arrange by number of missing values
  arrange(desc(rowSums(is.na(.))))


# inner join with data
cardholder_data <- inner_join(x = buyers_pivot, y = data, by = "account_id") %>% select(-c(date.loan, account_creation_date.account))

cardholder_data
```
## 3.4 EDA von Karten Kaeufer

Wir schauen uns an, was ueberhaupt ein Kartenkaeufer ausmacht und explorieren den komibinerten Datensatz
```{r fig.width=10, fig.height=10}
# loan?
# create a barplot and count has_loan
data %>%
  ggplot(aes(
    x = has_loan.loan,
    fill = has_card.card
  )) +
  geom_bar(position = "dodge") +
  labs(
    title = "Barplot von Kredit",
    x = "Kredit vorhanden?",
    y = "Anzahl"
  )

# issuance_statement_frequency.account?
# create a barplot and count issuance_statement_frequency.account
data %>%
  ggplot(aes(
    y = issuance_statement_frequency.account,
    fill = has_card.card
  )) +
  geom_bar(position = "dodge") +
  labs(
    title = "Barplot von issuance_statement_frequency.account",
    y = "issuance_statement_frequency.account",
    x = "Anzahl"
  )

# age distribution
data %>%
  ggplot(aes(
    x = age.client,
    fill = has_card.card
  )) +
  geom_histogram(bins = 35) +
  labs(
    title = "Histogramm von Alter",
    x = "Alter",
    y = "Anzahl"
  )

# has order?
data %>%
  ggplot(aes(
    x = has_order.order,
    fill = has_order.order
  )) +
  geom_bar(position = "dodge") +
  labs(
    title = "Barplot von Dauerauftrag",
    x = "Dauerauftrag vorhanden?",
    y = "Anzahl"
  )

# gender.client?
# create barplot for gender
data %>%
  ggplot(aes(
    x = gender.client,
    fill = has_card.card
  )) +
  geom_bar(position = "dodge") +
  labs(
    title = "Barplot nach Geschlecht",
    x = "Geschlecht",
    y = "Anzahl"
  )

# district_name.district?
data %>%
  ggplot(aes(
    y = district_name.district,
    fill = has_card.card
  )) +
  geom_bar(position = "dodge") +
  labs(
    title = "Barplot nach Distrikt",
    x = "Anzahl",
    y = "Distrikt"
  )



# region.district?
data %>%
  ggplot(aes(
    y = region.district,
    fill = has_card.card
  )) +
  geom_bar(position = "dodge") +
  labs(
    title = "Barplot nach Region",
    x = "Anzahl",
    y = "Region"
  )
```


## 3.4 Testing

Wir versuchen aus den Transaktionsdaten von den buyer die Attribute in einem geeignetem Format zu kriegen. Dabei unterscheiden wir die Kategorische und Numerische Spalten. Grundsaetzlich gruppieren wir nach account_id und year_month und zaehlen bei den kategorischen variabeln wie oft diese variable vorkommt. Bei den numerischen Werten berechnen wir Attribute wie Summe, Mittelwert, Median etc.... anschliessend joinen wir alles zu einem Dataframe und pivotieren diese. Beim pivotieren erhalten wir zu viele Spalten (mehr als 1000). (Behalten den Code, vlt brauchen wir den spaeter)
```{r}
# Extracting year and month from the date column
buyers$year_month <- format(as.Date(buyers$date), "%Y-%m")

buyers

# Handling categorical datatypes in transaction

trans_type <- buyers %>%
  group_by(account_id, year_month, type) %>%
  summarise(count_type = n()) %>%
  pivot_wider(names_from = type, values_from = count_type, values_fill = list(count_type = 0)) %>%
  rename(
    "n_credit.trans.type" = "CREDIT",
    "n_withdrawl.trans.type" = "WITHDRAWAL",
    "n_NA.trans.type" = "NA"
  )

trans_type

trans_operation <- buyers %>%
  group_by(account_id, year_month, operation) %>%
  summarise(count_operation = n()) %>%
  pivot_wider(names_from = operation, values_from = count_operation, values_fill = list(count_operation = 0)) %>%
  rename(
    "n_withdrawal_in_cash.trans.operation" = "WITHDRAWAL IN CASH",
    "n_NA.trans.operation" = "NA",
    "n_credit_in_cash.trans.operation" = "CREDIT IN CASH",
    "n_remittance_to_anoth_bank.trans.operation" = "REMITTANCE TO ANOTHER BANK",
    "n_collec_from_anoth_bank" = "COLLECTION FROM ANOTHER BANK"
  )

trans_operation

trans_k_symbol <- buyers %>%
  group_by(account_id, year_month, k_symbol) %>%
  summarise(count_type = n()) %>%
  pivot_wider(names_from = k_symbol, values_from = count_type, values_fill = list(count_type = 0)) %>%
  rename(
    "n_interest_credited.trans.ksymbol" = "INTEREST CREDITED",
    "n_statement_payment.trans.ksymbol" = "STATEMENT PAYMENT",
    "n_NA.trans.ksymbol" = "NA",
    "n_houshold.trans.ksymbol" = "HOUSHOLD",
    "n_insurrance_pay.trans.ksymbol" = "INSURRANCE PAYMENT",
    "n_loan_pay.trans.ksymbol" = "LOAN PAYMENT",
    "n_old_age_pension.trans.ksymbol" = "OLD-AGE PENSION",
    "n_interes_if_neg_balance.trans.ksymbol" = "INTERES IF NEGATIVE BALANCE",
  )

trans_k_symbol

# handling numerical values
trans_amount_balance <- buyers %>%
  group_by(account_id, year_month) %>%
  summarise(
    sum_amount.trans = sum(amount, na.rm = TRUE),
    mean_amount.trans = mean(amount, na.rm = TRUE),
    median_amount.trans = median(amount, na.rm = TRUE),
    min_amount.trans = min(amount, na.rm = TRUE),
    max_amount.trans = max(amount, na.rm = TRUE),
    sum_balance.trans = sum(balance, na.rm = TRUE),
    mean_balance.trans = mean(balance, na.rm = TRUE),
    median_balance.trans = median(balance, na.rm = TRUE),
    min_balance.trans = min(balance, na.rm = TRUE),
    max_balance.trans = max(balance, na.rm = TRUE),
    num_of_trans.trans = n(),
  )

trans_amount_balance

# Join everthing together into one big dataframe
trans_aggregated <- inner_join(trans_type, trans_operation, by = c("account_id", "year_month")) %>%
  inner_join(trans_k_symbol, by = c("account_id", "year_month")) %>%
  inner_join(trans_amount_balance, by = c("account_id", "year_month"))

trans_aggregated <-
  trans_aggregated

write_xlsx(head(trans_aggregated, 1000), path = "data_export\\xselling_banking_data.xlsx")

trans_aggregated_wider <- trans_aggregated %>%
  pivot_wider(
    names_from = year_month,
    values_from = -c(account_id, year_month)
  )

trans_aggregated_wider
```

# 4. Nicht-Käufer
Bestimmen der Nicht-Käufer zum Vergleich (inkl. Rollup-Fenster).

## 4.1 Bestimmung von Nicht-Käufer

Wir haben 3094 potentielle Kunden denen wir eine Karte anbieten könnten.
```{r}
# create a dataframe where has_card.card == FALSE
account_ids_no_cards <- data %>%
  filter(has_card.card == FALSE) %>%
  select(account_id)

account_ids_no_cards

non_buyers <- inner_join(
  x = account_ids_no_cards,
  y = trans,
  by = "account_id"
)

non_buyers$year_month <- format(as.Date(non_buyers$date), "%Y-%m")

non_buyers_pivot <- non_buyers %>%
  select(account_id, year_month) %>%
  mutate(value = 1) %>%
  pivot_wider(
    names_from = year_month,
    values_from = value, values_fn = sum
  )


# inner join with data
non_cardholder_data <- inner_join(x = non_buyers_pivot, y = data, by = "account_id") %>% select(-c(date.loan, account_creation_date.account))

non_cardholder_data
```

Note: putative/potential purchase drivers are selected and organized into a client analytical record
(“golden record”). To understand and communicate the impact of individual attributes univariate
exploratory analysis conditioned on the target attribute can be useful. For predictive models


## 4.2 Fiktives issued für Nicht-Käufer definieren
```{r}

```

## 4.3 Vergleich 
```{r}

```

## 4.4 Rollup-Fenster Vergleich
```{r}
visualize_account_balance(non_buyers,
  accounts_to_filter = c(1),
  window_size = 30
)
```

# 5. Event Bezogene Kundeninformationen 
Erzeugen event-bezogener Kundeninformationen für 12 Monate vor 
Kreditkartenkauf (analog für Nicht-Käufer).

## 5.1 Kundeninformation für 12 Monate von Käufer
```{r}

```

## 5.2 Kundeninformation für 12 Monate von Nicht-Käufer
```{r}

```

# 6. Vermögen & Umsätze
Konstruieren der Vermögen und Umsätze im Rollup-Fenster auf Basis 
der Transaktionshistorie.

## 6.1 Vermögen
```{r}

```

## 6.2 Umsätze
```{r}

```

# 7. Kunden-spezifische statistische Kennzahlen
Herleiten Kunden-spezifischer, statistischer Kennzahlen für Vermögen 
und Umsätze im Rollup-Fenster mittels Funktionen.

## 7.1 Funktion
```{r}

```

## 7.2 Statistische Kennzahlen für Vermögen
```{r}

```

## 7.3 Statistische Kennzahlen für Umsätze
```{r}

```

## 8. Kombination von Event Informationen & Kreditkarten Käufer
Kombinieren event-bezogener Informationen von KreditkartenKäufern und Nicht-Käufern.

## 8.1 Kombination
```{r}

```

# 9. Bereinigung
Bereinigen unnötiger Informationen (z.B. IDs) und Überprüfen der 
Struktur der Modellierungsdaten mittels explorativer Datenanalyse.

## 9.1 Daten Bereinigen
```{r}

```

## 9.2 Daten explorieren
```{r}

```

# 10. Partitionierung
Partitionieren der Daten in Trainings- und Testdaten.

## 10.1 Train-Test Split
```{r}

```

# 11. Baseline Modell
Erstellen eines Baseline Modelles mittels logistischer Regression und 
den Informationen “Alter”, “Geschlecht”, “Domizilregion”, 
“Vermögen” und “Umsatz” vor Kreditkartenkauf. 

## 11.1 Logistische Regression
```{r}

```

# 12. Verbesserung des Baseline Modell
Systematisches Explorieren von Verbesserungsmöglichkeiten des 
Baseline Modelles durch Erweiterung erklärender Variablen, 
Verwendung anderer Algorithmen und Optimierung.

## 12.1 Erweiterung 
```{r}

```

## 12.2 Andere Algorithmen 
```{r}

```

## 12.3 Andere Optimierungen
```{r}

```

# 13. Vergleich der Modelle
Vergleichen der Kandidatenmodelle und identifizieren des bzgl. 
Performance “besten” Modelles mit ROC, AUC und Precision.

## 13.1 Modell Vergleich
```{r}

```


# 14. Top-N Kunden 
 Quantitatives Untersuchen der Unterschiede von Top-N Kunden Listen verschiedener Modelle
 
## 14.1 Top-N Kunden Vergleich von Modellen
```{r}

```

 
# 15. Wichtigkeit und Balancierung
Untersuchen der globalen Wichtigkeit der Einflussfaktoren des 
“besten” Modelles und Reduzieren des “besten” Modelles mittels 
Balancieren von globaler Wichtigkeit und Modellperformance.

## 15.1 Wichtigkeit
```{r}

```

## 15.2 Balancierung 
```{r}

```


# 16. Beschreibung 
Beschreiben des Mehrwerts des “finalen” Modelles in der Praxis.
```{r}

```

# Lieferobjekte
Die minimalen Lieferobjekte im Notebook umfassen:

## Anzahl Kreditkarten-Käufer und Nicht-Käufer mit kompletter 12 
Monate-Rollup Information (Barplot).

## Verteilung der Kaufzeitpunkte der Kreditkarten-Käufer bzw. Vergleichszeitpunkte der Nicht-Käufer (Densityplot).

## Beschreibung der konstruierten, eigenen Variablen.

## Beschreibung von Baseline und mind. 3 Kandidaten-Modellen.

## Performance-Vergleich von Baseline und mind. 3 KandidatenModellen für 10-fache Kreuzvalidierung (Metrik: ROC Kurve und AuC). PRÄDIKTIVE MODELLE Mini-Challenge Lieferobjekte

## Performance-Vergleich von Baseline und mind. 3 KandidatenModellen für Testdaten (Metriken: Konfusionsmatrix, Accuracy,Kohen’s Kappa, Matthew’s Korrelation, Precision, Recall und F1 als Tabelle, ROC Kurve und AuC als Abbildung).

## Globale Wichtigkeit der Einflussfaktoren von Baseline und mind. 3. Kandidaten-Modellen (Variable Importance Plot).

## Quantifizierung der Unterschiede von Top-5%, Top-10% KundenListen für Baseline und mind. 3 Kandidaten-Modellen (eigene Ideen).

## Modellgüte (Lift Kurve) und Einfluss zentraler Variablen des finalen Modelles (eigene Ideen, um Non-Data Scientists zu überzeugen).
