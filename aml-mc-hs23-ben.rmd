---
title: "aml-mc-hs23-ben"
author: "Si Ben Tran"
date: "31.12.2023"
subtitle: Product Affinity Modelling
---

# Aufgaben
Aufgabe: Entwickle und evaluiere Affinitätsmodelle für Kreditkarten auf 
Basis von transaktionellen Kundeninformationen mittels binärer 
Klassifikation in Hinsicht auf personalisierte Werbekampagnen.

# Inhalt
• Aufbereitung eines Modellierungsdatensatz,  
• Modellentwicklung und systematischer Performance-Vergleich,  
• Vergleich der Haupteinflussfaktoren und Top-N Listen der Modelle,  
• Modell-Selektion und systematische Hyperparameter-Optimierung,  
• Modellvereinfachung und -beschreibung für Non-Data Scientist.  

# Libraries Laden
```{r echo=FALSE}
library(tidyverse)
library(tidymodels)
library(DataExplorer)
library(lubridate)
library(eeptools)
```


# 1. Daten
Laden, transformieren und überprüfen der Datenqualität mittels 
explorativer Datenanalyse; entfernen von Junior-Kreditkarten Kunden.

## 1.1 Laden
Insgesamt werden 8 verschiedene csv Files zur Verfuegung gestellt.
Die Beschreibungen der Daten sind hier zu finden: https://sorry.vse.cz/~berka/challenge/PAST/index.html

```{r}
# alle file namen
file_names <- c(
  "account.csv", "card.csv", "client.csv", "disp.csv",
  "district.csv", "loan.csv", "order.csv", "trans.csv"
)

# leere liste fuer dataframes
data_frames <- list()

# For loop durch file_name
for (file_name in file_names) {
  # path definieren
  file_path <- file.path("xselling_banking_data", file_name)
  
  # daten einlesen und in liste speichern
  data_frames[[file_name]] <- read.csv(file_path, header = TRUE, sep = ";")
}

# dataframes zuweisen
account <- data_frames[["account.csv"]]
card <- data_frames[["card.csv"]]
client <- data_frames[["client.csv"]]
disp <- data_frames[["disp.csv"]]
district <- data_frames[["district.csv"]]
loan <- data_frames[["loan.csv"]]
order <- data_frames[["order.csv"]]
trans <- data_frames[["trans.csv"]]
```


## 1.2 transformieren
### 1.2.1 account
Die Tabelle account besitzt 4 Spalten, die account_id selbst, district_id welches auf die tabelle district verweist. 
Frequency welches die Haeufigkeit der Austellung von Kontoauszuegen definiert sowie ein datum. 

Die Werte von frequency und datum muessen umgeaendert werden, weiter aendern wir ebenfalls den spaltenname von frequency zu issuance_statement_frequency.
```{r}
# Frequency
account <- account %>%
  mutate(frequency = case_when(
    frequency == "POPLATEK MESICNE" ~ "MONTHLY ISSUANCE",
    frequency == "POPLATEK TYDNE" ~ "WEEKLY ISSUANCE",
    frequency == "POPLATEK PO OBRATU" ~ " ISSUANCE AFTER TRANSACTION",
    TRUE ~ frequency  # Keep other values unchanged
  )) %>% 
  rename(issuance_statement_frequency = frequency)

# Datum 
account$date <- ymd(account$date)

# Zuweisen zur df liste
data_frames[["account.csv"]] <- account

account %>% sample_n(size = 5)
```

### 1.2.2 card
Die Tabelle card beinhaltet die card_id, dis_id (verweist auf disp df) 
type der Karte und issued. 
Bei card aendern wir das Format in YYMMDD um und ignorierien die Zeit. 
(Auch gemaess der Dokumentation, ist keine Zeit vorgesehen.)
```{r}
# Datum formatieren
card$issued <- as_date(ymd_hms(card$issued))

# Zuweisen zur df Liste
data_frames[["card.csv"]] <- card

# Df ausgeben
card %>% sample_n(size = 5)
```

### 1.2.3 client
client Tabelle hat client_id, birht_number mit einem speziellen Format, YYMMDD
fuer Maenner und YYMM + 50 DD fuer Frauen. Also sprich, wurden bei Frauen der Geburtsmonat um 50 addiert. Weiter gibt es noch die district_id, welches auf die district Tabelle verweist. 
```{r}
# Funktion zur Geschlechterbestimmung
get_gender <- function(birth_number) {
  year <- as.integer(substr(birth_number, 1, 2))
  month <- as.integer(substr(birth_number, 3, 4))
  day <- as.integer(substr(birth_number, 5, 6))
  
  # Bei Frauen wird der Geburtsmonat um 50 addiert
  if (month > 12) {
    gender <- "female"
  } else {
    gender <- "male"
  }
  
  return(gender)
}

# Geschlecht bestimmen und als neue Spalte hinzufügen
client$gender <- sapply(client$birth_number, get_gender)


# filter nach Frauen, erstelle jahr (19XX), Monat - 50 und Tag Spalte sowie Geburtstag. 
client_female <- client %>% filter(gender == "female") %>% mutate(birth_number, 
                                                 year = 
                                                   as.integer(paste("19", as.character(substr(birth_number, 1, 2)), sep = "")),
                                                 month = 
                                                   as.integer(substr(birth_number, 3, 4)) - 50, 
                                                 day = 
                                                   as.integer(substr(birth_number, 5, 6)),
                                                 birth_day = 
                                                   make_date(year, month, day)) %>% 
  select(client_id, year, month, day, birth_number = birth_day, district_id, gender)

# Analog fuer Maenner                                                 
client_male <- client %>% filter(gender == "male") %>% mutate(birth_number, 
                                                 year = 
                                                   as.integer(paste("19", as.character(substr(birth_number, 1, 2)), sep = "")),
                                                 month = 
                                                   as.integer(substr(birth_number, 3, 4)), 
                                                 day = 
                                                   as.integer(substr(birth_number, 5, 6)),
                                                 birth_day = 
                                                   make_date(year, month, day)) %>% 
  select(client_id, year, month, day, birth_number = birth_day, district_id, gender)

# Anzahl Zeilen ueberpruefen, ob diese mit dem Ursprungs DataFrame uebereinstimmen. 
if (nrow(rbind(client_female, client_male)) == nrow(client))
  client <- rbind(client_female, client_male)

# Berechnung des Alters auf basisjahr 31.12.1999
client$age <- age_calc(dob = client$birth_number, enddate = as.Date("1999-12-31"), units = "years", precise = FALSE)

# zuweisen zur df liste
data_frames[["client.csv"]] <- client

# ausgeben
client %>% sample_n(size = 5)
```

### 1.2.4 disp
disp hat disp_id, client_id, welches auf client dataframe verweist und account_id, welches auf account Tabelle verweist sowie den typ, wobei nur OWNER einen Dauerauftrag erstellen koennen und Kredite aufnehmen koennen.
```{r}
disp %>% sample_n(size = 5)
```

### 1.2.5 district
district hat nummerierte Spalten von A1 - A16. Dabei sind die Kurzel jeweils auf der Website aufgelistet fuer was diese stehen. Wir bennen die Spalten um, damit wir eine Ahnung haben, mit was wir arbeiten sollten. 

A1  district_id/district code	
A2	district name	
A3	region	
A4	no. of inhabitants	
A5	no. of municipalities with inhabitants < 499	
A6	no. of municipalities with inhabitants 500-1999	
A7	no. of municipalities with inhabitants 2000-9999	
A8	no. of municipalities with inhabitants >10000	
A9	no. of cities	
A10	ratio of urban inhabitants	
A11	average salary	
A12	unemploymant rate '95	
A13	unemploymant rate '96	
A14	no. of enterpreneurs per 1000 inhabitants	
A15	no. of commited crimes '95	
A16	no. of commited crimes '96

```{r}
district <- district %>% select(district_id = A1, district_name = A2,
                    region = A3, num_of_habitat = A4,
                    num_of_small_town = A5, num_of_medium_town = A6,
                    num_of_big_town = A7, num_of_bigger_town = A8,
                    num_of_city = A9, ratio_of_urban = A10,
                    average_salary = A11, unemploy_rate95 = A12,
                    unemploy_rate96 = A13, n_of_enterpren_per1000_inhabit = A14,
                    no_of_crimes95 = A15, no_of_crimes96 = A16)

# zuweisen zur df liste
data_frames[["district.csv"]] <- district

district %>% sample_n(size = 5)
```

### 1.2.6 loan
Loan hat loan_id, account_id (verweis auf account Tabelle), date in YYMMDD Format, amount, duration, payments, status.
Aendern werden wir payments zu monthly_payments und die Werte von
status. 
'A' stands for contract finished, no problems, => contract finished
'B' stands for contract finished, loan not payed, => finished contract, loan not payed
'C' stands for running contract, OK so far, => running contract
'D' stands for running contract, client in debt => client in debt

```{r}
loan$date <- ymd(loan$date)

loan <- loan %>%
  mutate(status = case_when(
    status == 'A' ~ 'contract finished',
    status == 'B' ~ 'finished contract, loan not paid',
    status == 'C' ~ 'running contract',
    status == 'D' ~ 'client in debt',))

# Zuweisen zur df liste
data_frames[["loan.csv"]] <- loan
    
loan %>% sample_n(size = 5)
```

### 1.2.7 order
die order Tabelle besteht aus order_id, account_id, bank_to (einzigartige Komibination aus 2 Buchstaben), account_to (zu welchem Account), amount, k_symbol (klassifizierung der Zahlung)
k_symbol wird auf englisch uebersetzt
```{r}
order <- order %>%
  mutate(k_symbol = case_when(
    k_symbol == 'POJISTNE' ~ 'INSURRANCE PAYMENT',
    k_symbol == 'SIPO' ~ 'HOUSHOLD',
    k_symbol == 'UVER' ~ 'LOAN PAYMENT'))

# zuweisen zur df liste
data_frames[["order.csv"]] <- order

order %>% sample_n(size = 5)

```

### 1.2.8 trans
Die trans Tabelle hat trans_id, account_id, date, type, operation, amount und banalce, k_symbol (analog zu order) bank und account


type, operation und k_symbol Werte werden auf Englisch uebersetzt
```{r}
trans <- trans %>% 
  mutate(date = ymd(date), 
         type = case_when(
           type == 'PRIJEM' ~ 'CREDIT',
           type == 'VYDAJ' ~ 'WITHDRAWAL'),
         operation = case_when(
           operation == 'VYBER KARTOU' ~ 'CREDIT CARD WITHDRAWAL',
           operation == 'VKLAD' ~ 'CREDIT IN CASH',
           operation == 'PREVOD Z UCTU' ~ 'COLLECTION FROM ANOTHER BANK',
           operation == 'VYBER' ~ 'WITHDRAWAL IN CASH',
           operation == 'PREVOD NA UCET' ~ 'REMITTANCE TO ANOTHER BANK'),
         k_symbol = case_when(
           k_symbol == 'POJISTNE' ~ 'INSURRANCE PAYMENT',
           k_symbol == 'SLUZBY' ~ 'STATEMENT PAYMENT',
           k_symbol == 'UROK' ~ 'INTEREST CREDITED',
           k_symbol == 'SANKC. UROK' ~ 'INTERES IF NEGATIVE BALANCE',
           k_symbol == 'SIPO' ~ 'HOUSHOLD',
           k_symbol == 'DUCHOD' ~ 'OLD-AGE PENSION',
           k_symbol == 'UVER' ~ 'LOAN PAYMENT',)
         )

# Zuweisen zur df liste
data_frames[["trans.csv"]] <- trans

trans %>% sample_n(size = 5)

```

## 1.3 Datenqualität mittels eda

```{r echo=FALSE}
# Function to perform EDA on a dataframe
perform_eda <- function(df, df_name) {
  # Create a data exploration report for the dataframe
  title <- paste("Exploratory Data Analysis for", df_name)
  create_report(df, report_title = title)
  
  # You can add more EDA steps here, such as additional plots and analysis
}

# Iterate through the list of dataframes and perform EDA on each
for (i in 1:length(data_frames)) {
  df_name <- names(data_frames)[i]  # Get the dataframe name
  perform_eda(data_frames[[i]], df_name)
}
```


### 1.3.1 District - Fehlende Werte
```{r}
# Es wurde festgestellt, dass im district DataFrame fehlende Werte bei folgenden Spalten auftrauchen: unemploy_rate_95, no_of_crime95, diese merkt man, das  das convertieren in ein integer datentyp nicht funktioniert. 


```


Mittels der Funktion perform_eda() generiert für jedes Dataframe eine Explorative Datenanalyse in html Format. Diese sind unter dem Verzeichnis: eda-dataexplorer-reports zu finden. 
Wir betrachten nun alle Dateframes vom Dataexplorer und halten unsere Kentnisse in diesem Abschnitt fest. 

account: 
Account besitzt keine fehlende Werte. Weiter fällt stark auf, dass bei issuance_statement_frequency der meiste vorkommende Wert MONTHLY ISSUANCE ist. 

card:
card besitzt keine fehlende Werte. Beim Barplot vom Typ sehen wir, dass classic die am häufigsten vertretene Klasse ist. Gefolgt wird diese von Junior und auf dem dritten Platz, mit am wenigsten vorkommenden sind gold.

client:
client weist keine fehlende Werte im Datensatz auf. Die Altersverteilung ist leicht linksschief. Wir erkennen im korrelationsplot, dass Jahr und Alter korrelieren, was jedoch nicht verwunderlich ist.

disp:
disp weist keine fehlende Werte im Datensatz auf. Die am meisten vorkommende Variable von type ist OWNER. DISPONENT kommt 1/4 mal weniger vor als OWNER.

district:
district weist ebenfalls keine fehlende Werte auf. average_salary ist rechtsschief verteilt. 

loan:

order:

trans:


## 1.4 entfernen von Junior Kreditkarten Kunden
```{r}
# checken, welche Variabeln vorhanden sind. 
print(paste("Kartentypen:", unique(card$type)))

# !junior dataframe
card_clean = subset(card, type != "junior")

# junior dataframe
card_junior = subset(card, type == "junior")

# Berechne Differenz von rows zwischen card_junior und card
print(paste("Anzahl entfernte junior Karten:", nrow(card_junior)))

# entfernen von allen disp_id in disp Dataframe, die in card_junior vorkommen.  (1:1)
disp_clean = subset(disp, !(disp_id %in% unique(card_junior$disp_id)))
print(paste("Anzahl entfernte disp_id, die von card_junior kommen:", nrow(disp) - nrow(disp_clean)))
```


# 2. Kombinieren 
Kombinieren der Informationen zu Kunden und Bankdienstleistungen.

Durch unsere Skizze die unter als "skizze-tabelle-joinen" abgelegt wurde, wissen wir nun wie die Tabellen miteinander verknuepft sind und konnen so einen Datensatz von Kunden und einen Datensatz von Bankdienstleistungen erstellen.  
```{r}
# client und disp weisen eine 1:1 relation auf client_id auf. 
print(paste("Anzahl Zeilen client df:", nrow(client)))
print(paste("Anzahl Zeilen disp df:", nrow(disp)))

# inner join by client_id 
client_disp <- inner_join(x = client, 
                          y = disp, 
                          by = "client_id", 
                          suffix = c(".client", ".disp")) %>%
  select(client_id, 
         district_id, 
         disp_id, 
         account_id,
         everything()) %>% 
  rename("year.client" = "year",
         "month.client" = "month",
         "day.client" = "day",
         "birht_number.client" = "birth_number",
         "gender.client" = "gender",
         "age.client" = "age",
         "type.disp" = "type")

print(paste("Anzahl Zeilen client_disp df:", nrow(client_disp)))
client_disp %>% sample_n(size = 5)

```
```{r}
# Weiter joinen wir client_disp und card mit disp_id. Auch hier besteht eine 1:1 Beziehung.

# Wir erkennen jedoch, dass es clienten gibt, die keine Karte besitzen. aus diesem Grund 

print(paste("Anzahl Zeilen card df:", nrow(card_clean)))

# left join 
client_disp_card <- left_join(x = client_disp,
                              y = card_clean,
                              by = "disp_id",
                              suffix = c("", ".card")) %>% 
  mutate(has_card = !rowSums(is.na(.))) %>% 
  select(-c(client_id, disp_id, card_id)) %>% 
  rename("type.card" = "type",
         "issued.card" = "issued",
         "has_card.card" = "has_card")

print(paste("Anzahl Zeilen client_disp_card df:", nrow(client_disp_card)))
client_disp_card %>% sample_n(size = 5)
```

```{r}
# Erweitern den Datensatz noch mit district Dataframe, indem wir einen Left join wieder machen. 

print(paste("Anzahl Zeilen district df:", nrow(district)))
print(paste("Anzahl Zeilen client_disp_card:", nrow(client_disp_card)))

client_disp_card_district <- left_join(client_disp_card,
                                       district,
                                       by = "district_id") %>% 
  rename(
    "district_name.district" = "district_name",
    "region.district" = "region",
    "num_of_habitat.district" = "num_of_habitat",
    "num_of_medium_town.district" = "num_of_medium_town",
    "num_of_small_town.district" = "num_of_small_town",
    "num_of_big_town.district" = "num_of_big_town",
    "num_of_bigger_town.district" = "num_of_bigger_town",
    "num_of_city.district" = "num_of_city",
    "ratio_of_urban.district" = "ratio_of_urban",
    "average_salary.district" = "average_salary",
    "unemploy_rate95.district" = "unemploy_rate95",
    "unemploy_rate96.district" = "unemploy_rate96",
    "n_of_enterpren_per1000_inhabit.district" = "n_of_enterpren_per1000_inhabit",
    "no_of_crimes95.district" = "no_of_crimes95",
    "no_of_crimes96.district" = "no_of_crimes96"
  )

print(paste("Anzahl Zeilen client_disp_card_district df:", nrow(client_disp_card_district)))
client_disp_card_district %>% sample_n(size = 5)

```

```{r}
# Ein Account kann mehrere disponenten haben. 
 
print(paste("Anzahl Zeilen account df:", nrow(account)))
print(paste("Anzahl Zeilen client_disp_card_district:", nrow(client_disp_card_district)))


client_disp_card_district_account <- left_join(x = account, 
                                               y = client_disp_card_district,
                                               by = "account_id") %>% 
  rename("district_id.account" = "district_id.x",
         "district_id.client" = "district_id.y",
         "issuance_statement_frequency.account" = "issuance_statement_frequency",
         "account_creation_date.account" = "date")


print(paste("Anzahl Zeilen client_disp_card_district_account df:", nrow(client_disp_card_district_account)))
client_disp_card_district_account
```


```{r}
# Ein account kann ein Kredit haben oder auch nicht. 
account_loan <- left_join(x = account,
                          y = loan,
                          by = "account_id") %>% 
  mutate(has_loan.loan = !rowSums(is.na(.))) %>% 
  rename("date.loan" = "date.y",
         "amount.loan" = "amount",
         "duration.loan" = "duration",
         "payments.loan" = "payments",
         "status.loan" = "status") %>% 
  select(-c(loan_id, district_id, issuance_statement_frequency, date.x))

account_loan
```

```{r}
# account_loan mit client_disp_card_district_account joinen
client_disp_card_district_account_loan <- right_join(x = account_loan,
                                                     y = client_disp_card_district_account,
                                                     by = "account_id")

client_disp_card_district_account_loan
```

```{r}
# Ein account kann mehrere transaktionen haben

client_disp_card_district_account_loan_trans <- left_join(x = trans,
                                                          y = client_disp_card_district_account_loan,
                                                          by = "account_id") %>% 
  rename("date.trans" = "date",
         "type.trans" = "type",
         "operation.trans" = "operation",
         "amount.trans" = "amount",
         "balance.trans" = "balance",
         "k_symbol.trans" = "k_symbol",
         "bank.trans" = "bank",
         "account.trans" = "account") %>% 
  select(-c(trans_id))

client_disp_card_district_account_loan_trans

```


```{r}
# ein account kann mehrere orders haben
left_join(x = order,
                                                                 y = account,
                                                                 by = "account_id") 
```




# 3. Identifizierung
Identifizieren bestehender Kreditkartenkäufer inkl. Bestimmung des
Kaufdatums und Rollup-Fensters, definiert durch 1 Monat Lag und 12
Monate History vor Kreditkartenkauf.

```{r}

```

## 3.1 Kaufdatum 
```{r}

```

## 3.2 Rollup-Fenster
```{r}

```

# 4. Nicht-Käufer
Bestimmen der Nicht-Käufer zum Vergleich (inkl. Rollup-Fenster).

## 4.1 Bestimmung
```{r}

```

## 4.2 Vergleich 
```{r}

```

## 4.3 Rollup-Fenster Vergleich
```{r}

```

# 5. Event Bezogene Kundeninformationen 
 Erzeugen event-bezogener Kundeninformationen für 12 Monate vor 
Kreditkartenkauf (analog für Nicht-Käufer).

## 5.1 Kundeninformation für 12 Monate von Käufer
```{r}

```

## 5.2 Kundeninformation für 12 Monate von Nicht-Käufer
```{r}

```

# 6. Vermögen & Umsätze
Konstruieren der Vermögen und Umsätze im Rollup-Fenster auf Basis 
der Transaktionshistorie.

## 6.1 Vermögen
```{r}

```

## 6.2 Umsätze
```{r}

```

# 7. Kunden-spezifische statistische Kennzahlen
Herleiten Kunden-spezifischer, statistischer Kennzahlen für Vermögen 
und Umsätze im Rollup-Fenster mittels Funktionen.

## 7.1 Funktion
```{r}

```

## 7.2 Statistische Kennzahlen für Vermögen
```{r}

```

## 7.3 Statistische Kennzahlen für Umsätze
```{r}

```

## 8. Kombination von Event Informationen & Kreditkarten Käufer
Kombinieren event-bezogener Informationen von KreditkartenKäufern und Nicht-Käufern.

## 8.1 Kombination
```{r}

```

# 9. Bereinigung
Bereinigen unnötiger Informationen (z.B. IDs) und Überprüfen der 
Struktur der Modellierungsdaten mittels explorativer Datenanalyse.

## 9.1 Daten Bereinigen
```{r}

```

## 9.2 Daten explorieren
```{r}

```

# 10. Partitionierung
Partitionieren der Daten in Trainings- und Testdaten.

## 10.1 Train-Test Split
```{r}

```

# 11. Baseline Modell
Erstellen eines Baseline Modelles mittels logistischer Regression und 
den Informationen “Alter”, “Geschlecht”, “Domizilregion”, 
“Vermögen” und “Umsatz” vor Kreditkartenkauf. 

## 11.1 Logistische Regression
```{r}

```

# 12. Verbesserung des Baseline Modell
Systematisches Explorieren von Verbesserungsmöglichkeiten des 
Baseline Modelles durch Erweiterung erklärender Variablen, 
Verwendung anderer Algorithmen und Optimierung.

## 12.1 Erweiterung 
```{r}

```

## 12.2 Andere Algorithmen 
```{r}

```

## 12.3 Andere Optimierungen
```{r}

```

# 13. Vergleich der Modelle
Vergleichen der Kandidatenmodelle und identifizieren des bzgl. 
Performance “besten” Modelles mit ROC, AUC und Precision.

## 13.1 Modell Vergleich
```{r}

```


# 14. Top-N Kunden 
 Quantitatives Untersuchen der Unterschiede von Top-N Kunden Listen verschiedener Modelle
 
## 14.1 Top-N Kunden Vergleich von Modellen
```{r}

```

 
# 15. Wichtigkeit und Balancierung
Untersuchen der globalen Wichtigkeit der Einflussfaktoren des 
“besten” Modelles und Reduzieren des “besten” Modelles mittels 
Balancieren von globaler Wichtigkeit und Modellperformance.

## 15.1 Wichtigkeit
```{r}

```

## 15.2 Balancierung 
```{r}

```


# 16. Beschreibung 
Beschreiben des Mehrwerts des “finalen” Modelles in der Praxis.
```{r}

```

# Lieferobjekte
Die minimalen Lieferobjekte im Notebook umfassen:

## Anzahl Kreditkarten-Käufer und Nicht-Käufer mit kompletter 12 
Monate-Rollup Information (Barplot).

## Verteilung der Kaufzeitpunkte der Kreditkarten-Käufer bzw. Vergleichszeitpunkte der Nicht-Käufer (Densityplot).

## Beschreibung der konstruierten, eigenen Variablen.

## Beschreibung von Baseline und mind. 3 Kandidaten-Modellen.

## Performance-Vergleich von Baseline und mind. 3 KandidatenModellen für 10-fache Kreuzvalidierung (Metrik: ROC Kurve und AuC). PRÄDIKTIVE MODELLE Mini-Challenge Lieferobjekte

## Performance-Vergleich von Baseline und mind. 3 KandidatenModellen für Testdaten (Metriken: Konfusionsmatrix, Accuracy,Kohen’s Kappa, Matthew’s Korrelation, Precision, Recall und F1 als Tabelle, ROC Kurve und AuC als Abbildung).

## Globale Wichtigkeit der Einflussfaktoren von Baseline und mind. 3. Kandidaten-Modellen (Variable Importance Plot).

## Quantifizierung der Unterschiede von Top-5%, Top-10% KundenListen für Baseline und mind. 3 Kandidaten-Modellen (eigene Ideen).

## Modellgüte (Lift Kurve) und Einfluss zentraler Variablen des finalen Modelles (eigene Ideen, um Non-Data Scientists zu überzeugen).
