---
title: "aml-mc-hs23-ben"
author: "Si Ben Tran"
date: "31.12.2023"
subtitle: Product Affinity Modelling
---

# Aufgaben
Aufgabe: Entwickle und evaluiere Affinitätsmodelle für Kreditkarten auf 
Basis von transaktionellen Kundeninformationen mittels binärer 
Klassifikation in Hinsicht auf personalisierte Werbekampagnen.

# Inhalt
• Aufbereitung eines Modellierungsdatensatz,  
• Modellentwicklung und systematischer Performance-Vergleich,  
• Vergleich der Haupteinflussfaktoren und Top-N Listen der Modelle,  
• Modell-Selektion und systematische Hyperparameter-Optimierung,  
• Modellvereinfachung und -beschreibung für Non-Data Scientist.  

# Libraries Laden
```{r echo=FALSE}
library(tidyverse)
library(tidymodels)
library(DataExplorer)
library(lubridate)
library(eeptools)
library(zoo)

```


# 1. Daten
Laden, transformieren und überprüfen der Datenqualität mittels 
explorativer Datenanalyse; entfernen von Junior-Kreditkarten Kunden.

## 1.1 Laden
Insgesamt werden 8 verschiedene csv Files zur Verfuegung gestellt.
Die Beschreibungen der Daten sind hier zu finden: https://sorry.vse.cz/~berka/challenge/PAST/index.html

```{r read dataframe}
# alle file namen
file_names <- c(
  "account.csv", "card.csv", "client.csv", "disp.csv",
  "district.csv", "loan.csv", "order.csv", "trans.csv"
)

# leere liste fuer dataframes
data_frames <- list()

# For loop durch file_name
for (file_name in file_names) {
  # path definieren
  file_path <- file.path("xselling_banking_data", file_name)

  # daten einlesen und in liste speichern
  data_frames[[file_name]] <- read.csv(file_path, header = TRUE, sep = ";")
}

# dataframes zuweisen
account <- data_frames[["account.csv"]]
card <- data_frames[["card.csv"]]
client <- data_frames[["client.csv"]]
disp <- data_frames[["disp.csv"]]
district <- data_frames[["district.csv"]]
loan <- data_frames[["loan.csv"]]
order <- data_frames[["order.csv"]]
trans <- data_frames[["trans.csv"]]
```


## 1.2 transformieren
### 1.2.1 account
Die Tabelle account besitzt 4 Spalten, die account_id selbst, district_id welches auf die tabelle district verweist. 
Frequency welches die Haeufigkeit der Austellung von Kontoauszuegen definiert sowie ein datum. 

Die Werte von frequency und datum muessen umgeaendert werden, weiter aendern wir ebenfalls den spaltenname von frequency zu issuance_statement_frequency.
```{r wrangle account}
# Frequency
account <- account %>%
  mutate(frequency = case_when(
    frequency == "POPLATEK MESICNE" ~ "MONTHLY ISSUANCE",
    frequency == "POPLATEK TYDNE" ~ "WEEKLY ISSUANCE",
    frequency == "POPLATEK PO OBRATU" ~ " ISSUANCE AFTER TRANSACTION",
    TRUE ~ frequency # Keep other values unchanged
  )) %>%
  rename(issuance_statement_frequency = frequency)

# Datum
account$date <- ymd(account$date)

# Zuweisen zur df liste
data_frames[["account.csv"]] <- account

account %>% sample_n(size = 5)
```

### 1.2.2 card
Die Tabelle card beinhaltet die card_id, dis_id (verweist auf disp df) 
type der Karte und issued. 
Bei card aendern wir das Format in YYMMDD um und ignorierien die Zeit. 
(Auch gemaess der Dokumentation, ist keine Zeit vorgesehen.)
```{r wrangle card}
# Datum formatieren
card$issued <- as_date(ymd_hms(card$issued))

# Zuweisen zur df Liste
data_frames[["card.csv"]] <- card

# Df ausgeben
card %>% sample_n(size = 5)
```

### 1.2.3 client
client Tabelle hat client_id, birht_number mit einem speziellen Format, YYMMDD
fuer Maenner und YYMM + 50 DD fuer Frauen. Also sprich, wurden bei Frauen der Geburtsmonat um 50 addiert. Weiter gibt es noch die district_id, welches auf die district Tabelle verweist. 
```{r wrangle client}
# Funktion zur Geschlechterbestimmung
get_gender <- function(birth_number) {
  year <- as.integer(substr(birth_number, 1, 2))
  month <- as.integer(substr(birth_number, 3, 4))
  day <- as.integer(substr(birth_number, 5, 6))

  # Bei Frauen wird der Geburtsmonat um 50 addiert
  if (month > 12) {
    gender <- "female"
  } else {
    gender <- "male"
  }

  return(gender)
}

# Geschlecht bestimmen und als neue Spalte hinzufügen
client$gender <- sapply(client$birth_number, get_gender)


# filter nach Frauen, erstelle jahr (19XX), Monat - 50 und Tag Spalte sowie Geburtstag.
client_female <- client %>%
  filter(gender == "female") %>%
  mutate(birth_number,
    year =
      as.integer(paste("19", as.character(substr(birth_number, 1, 2)), sep = "")),
    month =
      as.integer(substr(birth_number, 3, 4)) - 50,
    day =
      as.integer(substr(birth_number, 5, 6)),
    birth_day =
      make_date(year, month, day)
  ) %>%
  select(client_id, year, month, day, birth_number = birth_day, district_id, gender)

# Analog fuer Maenner
client_male <- client %>%
  filter(gender == "male") %>%
  mutate(birth_number,
    year =
      as.integer(paste("19", as.character(substr(birth_number, 1, 2)), sep = "")),
    month =
      as.integer(substr(birth_number, 3, 4)),
    day =
      as.integer(substr(birth_number, 5, 6)),
    birth_day =
      make_date(year, month, day)
  ) %>%
  select(client_id, year, month, day, birth_number = birth_day, district_id, gender)

# Anzahl Zeilen ueberpruefen, ob diese mit dem Ursprungs DataFrame uebereinstimmen.
if (nrow(rbind(client_female, client_male)) == nrow(client)) {
  client <- rbind(client_female, client_male)
}

# Berechnung des Alters auf basisjahr 31.12.1999
client$age <- age_calc(dob = client$birth_number, enddate = as.Date("1999-12-31"), units = "years", precise = FALSE)

# zuweisen zur df liste
data_frames[["client.csv"]] <- client

# ausgeben
client %>% sample_n(size = 5)
```

### 1.2.4 disp
disp hat disp_id, client_id, welches auf client dataframe verweist und account_id, welches auf account Tabelle verweist sowie den typ, wobei nur OWNER einen Dauerauftrag erstellen koennen und Kredite aufnehmen koennen.
```{r wrangle disp}
disp %>% sample_n(size = 5)
```

### 1.2.5 district
district hat nummerierte Spalten von A1 - A16. Dabei sind die Kurzel jeweils auf der Website aufgelistet fuer was diese stehen. Wir bennen die Spalten um, damit wir eine Ahnung haben, mit was wir arbeiten sollten. 

A1  district_id/district code	
A2	district name	
A3	region	
A4	no. of inhabitants	
A5	no. of municipalities with inhabitants < 499	
A6	no. of municipalities with inhabitants 500-1999	
A7	no. of municipalities with inhabitants 2000-9999	
A8	no. of municipalities with inhabitants >10000	
A9	no. of cities	
A10	ratio of urban inhabitants	
A11	average salary	
A12	unemploymant rate '95	
A13	unemploymant rate '96	
A14	no. of enterpreneurs per 1000 inhabitants	
A15	no. of commited crimes '95	
A16	no. of commited crimes '96

```{r wrangle district}
district <- district %>% select(
  district_id = A1, district_name = A2,
  region = A3, num_of_habitat = A4,
  num_of_small_town = A5, num_of_medium_town = A6,
  num_of_big_town = A7, num_of_bigger_town = A8,
  num_of_city = A9, ratio_of_urban = A10,
  average_salary = A11, unemploy_rate95 = A12,
  unemploy_rate96 = A13, n_of_enterpren_per1000_inhabit = A14,
  no_of_crimes95 = A15, no_of_crimes96 = A16
)

# zuweisen zur df liste
data_frames[["district.csv"]] <- district

district %>% sample_n(size = 5)
```

### 1.2.6 loan
Loan hat loan_id, account_id (verweis auf account Tabelle), date in YYMMDD Format, amount, duration, payments, status.
Aendern werden wir payments zu monthly_payments und die Werte von
status. 
'A' stands for contract finished, no problems, => contract finished
'B' stands for contract finished, loan not payed, => finished contract, loan not payed
'C' stands for running contract, OK so far, => running contract
'D' stands for running contract, client in debt => client in debt

Weiter checken wir, ob ein Account mehrere Loans haben kann, Gruppieren nach account und zaehlen die Anzahl Zeilen. Diese Fuegen wir dann spaeter zu unserem Loan DataFrame hinzu als weiteres Feature. 

```{r wrangle loan}
loan$date <- ymd(loan$date)

loan <- loan %>%
  mutate(status = case_when(
    status == "A" ~ "contract finished",
    status == "B" ~ "finished contract, loan not paid",
    status == "C" ~ "running contract",
    status == "D" ~ "client in debt",
  ))

num_of_loan_df <- loan %>%
  group_by(account_id) %>%
  summarize(num_of_loan = n()) %>%
  arrange(desc(num_of_loan))

num_of_loan_df

loan <- inner_join(
  x = loan,
  y = num_of_loan_df,
  by = "account_id"
)


# Zuweisen zur df liste
data_frames[["loan.csv"]] <- loan

loan %>% sample_n(size = 5)
```

### 1.2.7 order
die order Tabelle besteht aus order_id, account_id, bank_to (einzigartige Komibination aus 2 Buchstaben), account_to (zu welchem Account), amount, k_symbol (klassifizierung der Zahlung)
k_symbol wird auf englisch uebersetzt

Ein account kann mehrere Orders haben, um spaeter einfacher joinen zu koenen versuchen wir urch aggregieren nach account_id die Summe, Mittelwert, Median Ausgaben zu erhalten. Bei den Kategorischen Spalte k_symbol versuchen wir diese One-Hot zu encoden. 
```{r wrangle order}
order <- order %>%
  mutate(k_symbol = case_when(
    k_symbol == "POJISTNE" ~ "INSURRANCE PAYMENT",
    k_symbol == "SIPO" ~ "HOUSHOLD",
    k_symbol == "UVER" ~ "LOAN PAYMENT"
  ))

order$k_symbol[is.na(order$k_symbol)] <- "UNKOWN"

# Aggregating amount
aggregated_amount <- order %>%
  group_by(account_id) %>%
  summarise(
    sum_amount = sum(amount, na.rm = TRUE),
    mean_amount = mean(amount, na.rm = TRUE),
    median_amount = median(amount, na.rm = TRUE),
    min_amount = min(amount, na.rm = TRUE),
    max_amount = max(amount, na.rm = TRUE),
    num_of_orders = n()
  )

aggregated_amount


# Creating dummies
dummies_k_symbol <- order %>%
  select(account_id, k_symbol) %>%
  pivot_wider(
    names_from = k_symbol,
    values_from = k_symbol,
    values_fill = 0,
    values_fn = length
  )

dummies_k_symbol

# Merging dataframes
order <- left_join(aggregated_amount, dummies_k_symbol, by = "account_id")

# zuweisen zur df liste
data_frames[["order.csv"]] <- order

order %>% sample_n(size = 5)
```

### 1.2.8 trans
Die trans Tabelle hat trans_id, account_id, date, type, operation, amount und banalce, k_symbol (analog zu order) bank und account


type, operation und k_symbol Werte werden auf Englisch uebersetzt
```{r wrangle trans}
trans <- trans %>%
  mutate(
    date = ymd(date),
    type = case_when(
      type == "PRIJEM" ~ "CREDIT",
      type == "VYDAJ" ~ "WITHDRAWAL"
    ),
    operation = case_when(
      operation == "VYBER KARTOU" ~ "CREDIT CARD WITHDRAWAL",
      operation == "VKLAD" ~ "CREDIT IN CASH",
      operation == "PREVOD Z UCTU" ~ "COLLECTION FROM ANOTHER BANK",
      operation == "VYBER" ~ "WITHDRAWAL IN CASH",
      operation == "PREVOD NA UCET" ~ "REMITTANCE TO ANOTHER BANK"
    ),
    k_symbol = case_when(
      k_symbol == "POJISTNE" ~ "INSURRANCE PAYMENT",
      k_symbol == "SLUZBY" ~ "STATEMENT PAYMENT",
      k_symbol == "UROK" ~ "INTEREST CREDITED",
      k_symbol == "SANKC. UROK" ~ "INTERES IF NEGATIVE BALANCE",
      k_symbol == "SIPO" ~ "HOUSHOLD",
      k_symbol == "DUCHOD" ~ "OLD-AGE PENSION",
      k_symbol == "UVER" ~ "LOAN PAYMENT",
    )
  )

# Zuweisen zur df liste
data_frames[["trans.csv"]] <- trans

trans %>% sample_n(size = 5)
```

## 1.3 Datenqualität mittels eda

### 1.3.1 Fehlende Werte
Wir erkennen, dass die Transaktions Daten in der Tabelle order und trans fehlende Werte aufweisen. 

```{r fehlende Werte}
# check for missing values in each dataframe
for (i in 1:length(data_frames)) {
  df_name <- names(data_frames)[i] # Get the dataframe name
  cat("Missing values in", df_name, ":\n")
  print(sum(is.na(data_frames[[i]])))
}
```

### 1.3.1 District - Fehlende Werte

Bei genauer Betrachtung des Dataframes "district" ist aufgefallen, dass bei dessen Einlesen die Spalten "unemploy_rate95" und "no_of_crime95" als Zeichenketten (Character) eingelesen wurden. Bei beiden Spalten wurde der ein "?" verwendet statt NA. 
Hier in diesem Code Abschnitt imputieren den fehlenden Wert mit dem Mittelwert der jeweiligen Spalte.

```{r wramgle missing values, warning=FALSE}
# Datentyp convertieren
district$unemploy_rate95 <- as.numeric(district$unemploy_rate95)
district$no_of_crimes95 <- as.numeric(district$no_of_crimes95)

# fehlende Werte plotten
plot_missing(district)

# Imputation mittels mean
district$unemploy_rate95[is.na(district$unemploy_rate95)] <- mean(district$unemploy_rate95, na.rm = TRUE)
district$no_of_crimes95[is.na(district$no_of_crimes95)] <- mean(district$no_of_crimes95, na.rm = TRUE)

# fehlende Werte nach imputation plotten
plot_missing(district)
```


### 1.3.2 Data Explorer

Wir nutzen Data Explorer für eine erste Grobe Übersicht zu unseren Daten zu erhalten. 

```{r perform eda with DataExplorer}
# Function to perform EDA on a dataframe
perform_eda <- function(df, df_name) {
  # Create a data exploration report for the dataframe
  title <- paste("Exploratory Data Analysis for", df_name)
  create_report(df, report_title = title)

  # You can add more EDA steps here, such as additional plots and analysis
}

# Specify your directory path
path <- "eda-dataexplorer-reports"

# Check if directory exists
if (dir.exists(path)) {
  # List all files in directory
  list_of_files <- list.files(path)

  # Check if directory is empty
  if (length(list_of_files) == 0) {
    # Iterate through the list of dataframes and perform EDA on each
    for (i in 1:length(data_frames)) {
      df_name <- names(data_frames)[i] # Get the dataframe name
      perform_eda(data_frames[[i]], df_name)
    }
  } else {
    cat("Directory is not empty. Not running the EDA code.")
  }
} else {
  cat("Specified path does not exist. Please check the path and try again.")
}
```

Mittels der Funktion perform_eda() generiert für jedes Dataframe eine Explorative Datenanalyse in html Format. Diese sind unter dem Verzeichnis: eda-dataexplorer-reports zu finden. 
Wir betrachten nun alle Dateframes vom Dataexplorer und halten unsere Kentnisse in diesem Abschnitt fest. 

account: 
Account besitzt keine fehlende Werte. Weiter fällt stark auf, dass bei issuance_statement_frequency der meiste vorkommende Wert MONTHLY ISSUANCE ist. 

card:
card besitzt keine fehlende Werte. Beim Barplot vom Typ sehen wir, dass classic die am häufigsten vertretene Klasse ist. Gefolgt wird diese von Junior und auf dem dritten Platz, mit am wenigsten vorkommenden sind gold.

client:
client weist keine fehlende Werte im Datensatz auf. Die Altersverteilung ist leicht linksschief. Wir erkennen im korrelationsplot, dass Jahr und Alter korrelieren, was jedoch nicht verwunderlich ist.

disp:
disp weist keine fehlende Werte im Datensatz auf. Die am meisten vorkommende Variable von type ist OWNER. DISPONENT kommt 1/4 mal weniger vor als OWNER.

district:
district weist ebenfalls keine fehlende Werte auf. average_salary ist rechtsschief verteilt. 

loan:

order:

trans:


## 1.4 entfernen von Junior Kreditkarten Kunden
```{r remove junior card}
# checken, welche Variabeln vorhanden sind.
print(paste("Kartentypen:", unique(card$type)))

# !junior dataframe
card_clean <- subset(card, type != "junior")

# junior dataframe
card_junior <- subset(card, type == "junior")

# Berechne Differenz von rows zwischen card_junior und card
print(paste("Anzahl entfernte junior Karten:", nrow(card_junior)))

# entfernen von allen disp_id in disp Dataframe, die in card_junior vorkommen.  (1:1)
disp_clean <- subset(disp, !(disp_id %in% unique(card_junior$disp_id)))
print(paste("Anzahl entfernte disp_id, die von card_junior kommen:", nrow(disp) - nrow(disp_clean)))
```


# 2. Kombinieren 
Kombinieren der Informationen zu Kunden und Bankdienstleistungen.

Durch unsere Skizze die unter als "skizze-tabelle-joinen" abgelegt wurde, wissen wir nun wie die Tabellen miteinander verknuepft sind und konnen so einen Datensatz von Kunden und einen Datensatz von Bankdienstleistungen erstellen.  

## 2.1 client - disp

Wir innen joinen client und disp mit client_id, renamen die Spaltenamen und fügen jeweils ein suffix hinzu, um später noch eine Übersicht zu haben, von welcher Tabelle die Spalte entspringt. Beim inner joinen verlieren wir keine Kunden. Nach dem Joinen wissen wir von jedem Kunden, was für eine Art type der Kunde ist. OWNER oder DISPONENT.  

```{r cmobine client-disp}
# client und disp weisen eine 1:1 relation auf client_id auf.
print(paste("Anzahl Zeilen client df:", nrow(client)))
print(paste("Anzahl Zeilen disp df:", nrow(disp)))

# inner join by client_id
client_disp <- inner_join(
  x = client,
  y = disp,
  by = "client_id",
  suffix = c(".client", ".disp")
) %>%
  select(
    client_id,
    district_id,
    disp_id,
    account_id,
    everything()
  ) %>%
  rename(
    "year.client" = "year",
    "month.client" = "month",
    "day.client" = "day",
    "birht_number.client" = "birth_number",
    "gender.client" = "gender",
    "age.client" = "age",
    "type.disp" = "type"
  )

print(paste("Anzahl Zeilen client_disp df:", nrow(client_disp)))
client_disp %>% sample_n(size = 5)
```

### 2.1.1 gender vs. type
Die meisten unserer Kunden sind vom typ her OWNER. Das Geschlecht ob man OWNER oder DISPONENT ist sehen bei beiden Verteilungen ähnlich gleich aus. 

```{r eda}
ggplot(client_disp, aes(
  x = age.client,
  color = gender.client
)) +
  geom_histogram(
    alpha = 0.2,
    fill = "white",
    position = "dodge"
  ) +
  labs(
    title = "Verteilung von Alter unterteilt nach Geschlecht und Typ",
    x = "Alter",
    y = "Anzahl"
  ) +
  facet_grid(gender.client ~ type.disp)
```

## 2.2 +card

Wir joinen client_disp mit card über disp_id. Nicht jeder Kunde besitzt eine Karte, somit ist ein left join auf client_disp unsere Wahl, um keine Kunden zu verlieren. Weiter wurde eine weitere spalte erstellt, die uns markiert, ob der Kunde eine Karte besitzt oder nicht. Dies könnte später noch relevant werden bei der Evaluierung unsere Modelle.
```{r +card}
# Weiter joinen wir client_disp und card mit disp_id. Auch hier besteht eine 1:1 Beziehung.

# Wir erkennen jedoch, dass es clienten gibt, die keine Karte besitzen. aus diesem Grund

print(paste("Anzahl Zeilen card df:", nrow(card_clean)))

# left join
client_disp_card <- left_join(
  x = client_disp,
  y = card_clean,
  by = "disp_id",
  suffix = c("", ".card")
) %>%
  mutate(has_card = !rowSums(is.na(.))) %>%
  select(-c(client_id, disp_id, card_id)) %>%
  rename(
    "type.card" = "type",
    "issued.card" = "issued",
    "has_card.card" = "has_card"
  )

print(paste("Anzahl Zeilen client_disp_card df:", nrow(client_disp_card)))
client_disp_card
```
### 2.2.1 type vs. has_card
Aus der Visualisierung erkennen wir, dass keine Disponenten existieren die eine Karte besitzen. Aus diesem Grund filtern wir unseren Datensatz nur nach Owner, da wir diesen Personen eine Karte anbieten, bzw Karten wie classic oder gold besitzen bzw. verkaufen koennten. 

```{r eda}
ggplot(client_disp_card, aes(
  x = age.client,
  color = has_card.card
)) +
  geom_histogram(
    alpha = 0.5,
    fill = "white"
  ) +
  labs(title = "Verteilung von Alter unterteilt nach Kartentyp und Art", x = "Alter", y = "Anzahl") +
  facet_grid(type.card ~ type.disp)
```

### 2.2.2 groupby account_id
Kann ein Kunde Disponent und OWNER gleichzeitig sein?

Ja es gibt Account die mehrere Zeilen beinhalten. 
```{r eda}
# groupby account and count number of rows
client_disp_card %>%
  group_by(account_id) %>%
  summarize(num_of_rows = n()) %>%
  arrange(desc(num_of_rows))
```

## 2.3 Filter nach OWNER

Durch das Filtern verlieren wir 869 Kunden. Es bleiben von den 5369 Kunden nun noch 4500. 
```{r filter for owner}
# Filtern nach type.disp == "OWNER"
print(paste("Anzahl entfernte Zeilen von client_disp_card df:", nrow(client_disp_card) - nrow(client_disp_card %>% filter(type.disp == "OWNER"))))

client_disp_card <- client_disp_card %>% filter(type.disp == "OWNER")
client_disp_card
```

### 2.3.1 groupby account_id

Das das Filtern stellen wir nun fest, dass jeder Kunde nur ein Account bei der Bank besitzt. Diese koennen wir nun nutzen, um mit dem DataFrame account zu joinen. 
```{r eda}
# groupby account and count number of rows
client_disp_card %>%
  group_by(account_id) %>%
  summarize(num_of_rows = n()) %>%
  arrange(desc(num_of_rows))
```


## 2.4 + account
Durch die Erkentnisse von 2.3.1 koennen wir nun einen Inner Join durchfuehren von unserem vorhanden dataframe client-disp-card mit account Tabelle. 
Die Anzahl der Kunden bleibt somit gleich auf 4500. 
```{r +account}
# Ein Account kann mehrere disponenten haben.

print(paste("Anzahl Zeilen account df:", nrow(account)))
print(paste("Anzahl Zeilen client_disp_card:", nrow(client_disp_card)))


client_disp_card_account <- inner_join(
  x = account,
  y = client_disp_card,
  by = "account_id"
) %>%
  rename(
    "district_id.account" = "district_id.x",
    "district_id.client" = "district_id.y",
    "issuance_statement_frequency.account" = "issuance_statement_frequency",
    "account_creation_date.account" = "date"
  )


print(paste("Anzahl Zeilen client_disp_card_account df:", nrow(client_disp_card_account)))
client_disp_card_account
```

## 2.5 loan - account

Wir betrachten hier nun account und loan getrennt von unserem gejointen Dataframe. Erst in einem zweiten Schritt joinen wir beide Dataframes dann miteinander. Da ein Account ein Kredit haben kann oder nicht, fuehren wir einen left_join auf account ueber account_id.

```{r loan-account}
# Ein account kann ein Kredit haben oder auch nicht.
account_loan <- left_join(
  x = account,
  y = loan,
  by = "account_id"
) %>%
  mutate(has_loan.loan = !rowSums(is.na(.))) %>%
  rename(
    "date.loan" = "date.y",
    "amount.loan" = "amount",
    "duration.loan" = "duration",
    "payments.loan" = "payments",
    "status.loan" = "status",
    "num_of_loan.loan" = "num_of_loan"
  ) %>%
  select(-c(loan_id, district_id, issuance_statement_frequency, date.x))

account_loan
```

### 2.5.1 NA Werte
Durch das Joinen haben wir viele Spalten erhalten die NA Werte aufweisen. Bzw. nur die Spalten die von Loan kommen. Diese werden durch 0 oder no_loan ersetzt, da diese Accounts keinen Kredit besitzen. Beim Datum belassen wir die NA Werte

```{r reaplce NA values}
# reaplce NA values with 0 or no_loan
account_loan <- account_loan %>%
  mutate(
    amount.loan = ifelse(is.na(amount.loan), 0, amount.loan),
    duration.loan = ifelse(is.na(duration.loan), 0, duration.loan),
    payments.loan = ifelse(is.na(payments.loan), 0, payments.loan),
    status.loan = ifelse(is.na(status.loan), "no_loan", status.loan),
    num_of_loan.loan = ifelse(is.na(num_of_loan.loan), 0, num_of_loan.loan)
  )
```


### 2.5.2 amount vs. payments

Wir betrachten hier nun account und loan getrennt von unserem gejointen Dataframe. Erst in einem zweiten Schritt joinen account_loan und client_disp_card_account mit der Spalte account_id zusammen und fuehren eine kurze explorative Datenanalyse durch. 

Interessant zu sehen ist, dass die meisten Kredite schon abbezahlt wurden die eine Dauer von 12 Monaten aufweisen. 

Viele Account haben keinen Kredit aufgenommen.

```{r eda, warning=FALSE}
# Kredithoehe vs. Payments mit dauer und status
sample_n(account_loan, size = 1000) %>%
  ggplot(aes(
    x = amount.loan,
    y = payments.loan,
    shape = as.factor(duration.loan),
    color = status.loan
  )) +
  geom_point(alpha = 1) +
  labs(
    title = "Zahlung vs. Menge Kredit, unterteilt nach Dauer und",
    x = "Kreditmenge",
    y = "Zahlung"
  )

# Anzahl Kredite unterteilt nach Status
account_loan %>%
  ggplot(aes(
    x = has_loan.loan,
    fill = status.loan
  )) +
  geom_bar(position = "stack") +
  labs(
    title = "Stacked Barplot",
    x = "Kredit",
    y = "Anzahl"
  )
```


## 2.6 + account_loan

Wir joinen nun beide groesseren Dataframes ueber account_id. Beide Dataframes weisen 4500 Zeilen, somit haben wir nach dem joinen immer noch 4500 Kunden, welche 22 Features aufweisen. 
```{r +amount_loan}
# account_loan mit client_disp_card_district_account joinen
client_disp_card_account_loan <- inner_join(
  x = account_loan,
  y = client_disp_card_account,
  by = "account_id"
)

print(paste("Anzahl Zeilen client_disp_card_account df:", nrow(client_disp_card_account_loan)))
client_disp_card_account_loan
```



### 2.6.1 loan vs. card?
Was uns nun intressiert ist der Zusammenhang zwischen eine Karte zu besitzen und einen Kredit aufzuweisen. 

Es gibt Kunden die eine Karte haen und einen Kredit, analog gibt es auch Kunden die keine Karte haben, aber einen Kredit oder nicht. Somit behalten wir in unserem Datensatz die Kundschaft bei.

```{r eda}
client_disp_card_account_loan %>%
  ggplot(aes(
    x = has_loan.loan,
    fill = has_card.card
  )) +
  geom_bar(position = "dodge") +
  labs(
    title = "Barplot",
    x = "Kredit vorhanden?",
    y = "Anzahl"
  ) +
  facet_grid(type.card ~ issuance_statement_frequency.account)
```

### 2.6.2 Anzahl Kunden?
Wir überprüfen unser DataFrame ob eine Zeile einen Kunden entspricht indem wir nach account_id gruppieren und die Rows zaehlen.

In unserem DataFrame ist jede Zeile ein Kunde. Somit konnte jedem Kunden ein Bank Account zugewiesen werden. 
```{r eda}
# groupby account and count number of rows
client_disp_card_account_loan %>%
  group_by(account_id) %>%
  summarize(num_of_rows = n()) %>%
  arrange(desc(num_of_rows))
```

## 2.7 +order

Von unseren Urspruenglichen 4500 Zeilen, bzw Kunden hat nicht jeder Kunde ein Order betaetigt. Somit entfallen beim Inner Joinen einige Kunden, die jedoch nicht relevant fuer uns sind.
```{r +order}
# inner join by account_id client_disp_card_district_account_loan und order

print(paste("Anzahl Zeilen client_disp_card_account_loan_order df:", nrow(client_disp_card_account_loan)))
print(paste("Anzahl Zeilen order :", nrow(order)))


client_disp_card_account_loan_order <- inner_join(
  x = client_disp_card_account_loan,
  y = order,
  by = "account_id"
) %>% rename(
  "sum_amount.order" = "sum_amount", 
  "mean_amount.order" = "mean_amount",
  "median_amount.order" = "median_amount",
  "min_amount.order" = "min_amount",
  "max_amount.order" = "max_amount",
  "num_of_orders.order" = "num_of_orders",
  "num_insurrance_payment.order" = "INSURRANCE PAYMENT",
  "num_household.order" = "HOUSHOLD",
  "num_loan_payment.order" = "LOAN PAYMENT",
  "num_unkown.order" = "UNKOWN"
) %>% 
  arrange(account_id)

print(paste("Anzahl entfernte Zeilen von client_disp_card_account_loan df:", nrow(client_disp_card_account_loan) - nrow(client_disp_card_account_loan_order)))

client_disp_card_account_loan_order
```

## 2.8 +district
Wir erweitern unseren Datensatz mit dem district. Wichtig dabei zu beachten ist, dass wir jeweils einen district fuer die Filiale der Bank haben und einen district fuer den Kunden. In unserem Fall joinen wir unser Dataframe mit dem des Kunden, da uns dieser mehr interessiert, ob geographische Einfluesse den Kauf eines Bank Produktes.

```{r +district}
print(paste("Anzahl Zeilen district df:", nrow(district)))
print(paste("Anzahl Zeilen client_disp_card_account_loan_order:", nrow(client_disp_card_account_loan_order)))

client_disp_card_account_loan_order_district <- left_join(client_disp_card_account_loan_order %>% rename("district_id" = "district_id.client"),
  district,
  by = "district_id"
) %>%
  rename(
    "district_name.district" = "district_name",
    "region.district" = "region",
    "num_of_habitat.district" = "num_of_habitat",
    "num_of_medium_town.district" = "num_of_medium_town",
    "num_of_small_town.district" = "num_of_small_town",
    "num_of_big_town.district" = "num_of_big_town",
    "num_of_bigger_town.district" = "num_of_bigger_town",
    "num_of_city.district" = "num_of_city",
    "ratio_of_urban.district" = "ratio_of_urban",
    "average_salary.district" = "average_salary",
    "unemploy_rate95.district" = "unemploy_rate95",
    "unemploy_rate96.district" = "unemploy_rate96",
    "n_of_enterpren_per1000_inhabit.district" = "n_of_enterpren_per1000_inhabit",
    "no_of_crimes95.district" = "no_of_crimes95",
    "no_of_crimes96.district" = "no_of_crimes96"
  ) %>% 
  select(-c(district_id))

print(paste("Anzahl Zeilen client_disp_card_account_loan_order_district df:", nrow(client_disp_card_account_loan_order_district)))

client_disp_card_account_loan_order_district 

data <- client_disp_card_account_loan_order_district
```

## 2.9 +trans?
Ein Account kann mehrere Transaktionen gemacht haben. 
- droppen von unnoetigen Transaktion spalten
- Aggregation fuer Numerische (Mean, Median etc...)
- Aggregation mir Rolling Window von balance und
- OneHotEncoding fuer Kategorische

```{r +trans?}
trans <- trans %>% 
  select(-c(trans_id, account, bank)) %>% 
  arrange(account_id)
trans
```


```{r}
# filter in trans dataframe for account_id = 1 and 2 
trans_1_and_2 <- trans %>% filter(account_id %in% c(1, 2))

# Calculating 30-day rolling mean
trans_1_and_2 <- trans_1_and_2 %>% 
  arrange(account_id, date) %>%
  group_by(account_id) %>%
  mutate(rolling_mean = rollmean(balance, k = 30, fill = NA, align = "center"))

trans_1_and_2


# Create a time lineplot, where on the x axis is the date and y axis balance and amount.
ggplot(trans_1_and_2, aes(x = date)) +
  geom_line(aes(y = balance, 
                color = as.factor(account_id), 
                alpha = 0.5, 
                linetype = "dashed")) +
  geom_line(aes(y = rolling_mean, 
                color = as.factor(account_id)), 
            linetype = "solid") +
  labs(
    title = "Balance and 30-Day Rolling Mean Over Time",
    x = "Date",
    y = "Balance",
    color = "Account ID"
  ) 



```

```{r}

```



# 3. Identifizierung
Identifizieren bestehender Kreditkartenkäufer inkl. Bestimmung des
Kaufdatums und Rollup-Fensters, definiert durch 1 Monat Lag und 12
Monate History vor Kreditkartenkauf.

```{r}

```

## 3.1 Kaufdatum 
```{r}

```

## 3.2 Rollup-Fenster
```{r}

```

# 4. Nicht-Käufer
Bestimmen der Nicht-Käufer zum Vergleich (inkl. Rollup-Fenster).

## 4.1 Bestimmung
```{r}

```

## 4.2 Vergleich 
```{r}

```

## 4.3 Rollup-Fenster Vergleich
```{r}

```

# 5. Event Bezogene Kundeninformationen 
 Erzeugen event-bezogener Kundeninformationen für 12 Monate vor 
Kreditkartenkauf (analog für Nicht-Käufer).

## 5.1 Kundeninformation für 12 Monate von Käufer
```{r}

```

## 5.2 Kundeninformation für 12 Monate von Nicht-Käufer
```{r}

```

# 6. Vermögen & Umsätze
Konstruieren der Vermögen und Umsätze im Rollup-Fenster auf Basis 
der Transaktionshistorie.

## 6.1 Vermögen
```{r}

```

## 6.2 Umsätze
```{r}

```

# 7. Kunden-spezifische statistische Kennzahlen
Herleiten Kunden-spezifischer, statistischer Kennzahlen für Vermögen 
und Umsätze im Rollup-Fenster mittels Funktionen.

## 7.1 Funktion
```{r}

```

## 7.2 Statistische Kennzahlen für Vermögen
```{r}

```

## 7.3 Statistische Kennzahlen für Umsätze
```{r}

```

## 8. Kombination von Event Informationen & Kreditkarten Käufer
Kombinieren event-bezogener Informationen von KreditkartenKäufern und Nicht-Käufern.

## 8.1 Kombination
```{r}

```

# 9. Bereinigung
Bereinigen unnötiger Informationen (z.B. IDs) und Überprüfen der 
Struktur der Modellierungsdaten mittels explorativer Datenanalyse.

## 9.1 Daten Bereinigen
```{r}

```

## 9.2 Daten explorieren
```{r}

```

# 10. Partitionierung
Partitionieren der Daten in Trainings- und Testdaten.

## 10.1 Train-Test Split
```{r}

```

# 11. Baseline Modell
Erstellen eines Baseline Modelles mittels logistischer Regression und 
den Informationen “Alter”, “Geschlecht”, “Domizilregion”, 
“Vermögen” und “Umsatz” vor Kreditkartenkauf. 

## 11.1 Logistische Regression
```{r}

```

# 12. Verbesserung des Baseline Modell
Systematisches Explorieren von Verbesserungsmöglichkeiten des 
Baseline Modelles durch Erweiterung erklärender Variablen, 
Verwendung anderer Algorithmen und Optimierung.

## 12.1 Erweiterung 
```{r}

```

## 12.2 Andere Algorithmen 
```{r}

```

## 12.3 Andere Optimierungen
```{r}

```

# 13. Vergleich der Modelle
Vergleichen der Kandidatenmodelle und identifizieren des bzgl. 
Performance “besten” Modelles mit ROC, AUC und Precision.

## 13.1 Modell Vergleich
```{r}

```


# 14. Top-N Kunden 
 Quantitatives Untersuchen der Unterschiede von Top-N Kunden Listen verschiedener Modelle
 
## 14.1 Top-N Kunden Vergleich von Modellen
```{r}

```

 
# 15. Wichtigkeit und Balancierung
Untersuchen der globalen Wichtigkeit der Einflussfaktoren des 
“besten” Modelles und Reduzieren des “besten” Modelles mittels 
Balancieren von globaler Wichtigkeit und Modellperformance.

## 15.1 Wichtigkeit
```{r}

```

## 15.2 Balancierung 
```{r}

```


# 16. Beschreibung 
Beschreiben des Mehrwerts des “finalen” Modelles in der Praxis.
```{r}

```

# Lieferobjekte
Die minimalen Lieferobjekte im Notebook umfassen:

## Anzahl Kreditkarten-Käufer und Nicht-Käufer mit kompletter 12 
Monate-Rollup Information (Barplot).

## Verteilung der Kaufzeitpunkte der Kreditkarten-Käufer bzw. Vergleichszeitpunkte der Nicht-Käufer (Densityplot).

## Beschreibung der konstruierten, eigenen Variablen.

## Beschreibung von Baseline und mind. 3 Kandidaten-Modellen.

## Performance-Vergleich von Baseline und mind. 3 KandidatenModellen für 10-fache Kreuzvalidierung (Metrik: ROC Kurve und AuC). PRÄDIKTIVE MODELLE Mini-Challenge Lieferobjekte

## Performance-Vergleich von Baseline und mind. 3 KandidatenModellen für Testdaten (Metriken: Konfusionsmatrix, Accuracy,Kohen’s Kappa, Matthew’s Korrelation, Precision, Recall und F1 als Tabelle, ROC Kurve und AuC als Abbildung).

## Globale Wichtigkeit der Einflussfaktoren von Baseline und mind. 3. Kandidaten-Modellen (Variable Importance Plot).

## Quantifizierung der Unterschiede von Top-5%, Top-10% KundenListen für Baseline und mind. 3 Kandidaten-Modellen (eigene Ideen).

## Modellgüte (Lift Kurve) und Einfluss zentraler Variablen des finalen Modelles (eigene Ideen, um Non-Data Scientists zu überzeugen).
